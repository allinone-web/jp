ä¸€å¥—ã€Œæœ€å®Œç¾ã€å¿…å®šè§£å†³é—®é¢˜ã€çš„æ•´åˆæ–¹æ¡ˆ

ä¸‹é¢æ˜¯ç»“æ„æ–¹æ¡ˆï¼Œä¸æ˜¯å‡ä»£ç ï¼Œè¿™æ˜¯ä½ ç°åœ¨è¿™å¥—ç³»ç»Ÿå”¯ä¸€æ­£ç¡®çš„æ¼”è¿›æ–¹å‘ã€‚

ğŸ§  æ ¸å¿ƒåŸåˆ™ï¼ˆå¿…é¡»éµå®ˆï¼‰

Combat å†³å®šâ€œæˆ‘è¦å¹²å˜›â€

Movement å†³å®šâ€œæˆ‘ä»€ä¹ˆæ—¶å€™å¹²å®Œèµ°è·¯â€

æ”»å‡»åªèƒ½å‘ç”Ÿåœ¨â€œå·²å®Œæˆç§»åŠ¨â€çš„å¸§

âœ… æœ€ç»ˆ Combat çŠ¶æ€æœºï¼ˆé€»è¾‘å±‚ï¼‰
Combat åªç»´æŠ¤ 4 ä¸ªçŠ¶æ€ï¼ˆå¤Ÿäº†ï¼‰
enum AutoCombatState
{
    Idle,
    Chasing,
    Arrived,   // â˜… æ–°å¢ï¼šå·²åˆ°æ”»å‡»ä½
    Attacking
}

âœ… Movement å¿…é¡»æä¾›ä¸€ä¸ªä¿¡å·ï¼ˆè¿™æ˜¯å…³é”®ï¼‰

åœ¨ Movement.cs é‡Œï¼Œå½“ä¸€æ¬¡ StartWalking çš„ Tween çœŸæ­£ç»“æŸæ—¶ï¼š

public bool HasArrivedThisFrame { get; private set; }


æˆ–äº‹ä»¶ï¼š

OnMovementStepFinished();


ğŸ‘‰ ä¸ç”¨å¤æ‚ï¼Œä¸€ä¸ª bool å°±å¤Ÿ

âœ… æœ€ç»ˆ Combat ä¸»å¾ªç¯ï¼ˆç»“æ„ç‰ˆï¼‰
switch (_combatState)
{
    case Chasing:
        if (dist > range)
        {
            if (!_isAutoWalking)
                StartWalking(nextCell);
        }
        else
        {
            // ä¸ç›´æ¥æ”»å‡»ï¼
            // ç­‰ Movement å‘Šè¯‰æˆ‘â€œä½ å·²ç»åœç¨³â€
            _combatState = AutoCombatState.Arrived;
        }
        break;

    case Arrived:
        // â˜… å…³é”®ä¿®å¤ç‚¹ â˜…
        if (!_isAutoWalking && _movement.HasArrivedThisFrame)
        {
            StopWalking(); // ç°åœ¨æ˜¯â€œå®‰å…¨â€çš„
            _combatState = AutoCombatState.Attacking;
        }
        break;

    case Attacking:
        if (!_attackInProgress)
        {
            FaceTarget();
            PerformAttackOnce();
            _attackInProgress = true;
        }
        break;
}

ğŸš€ è¿™ä¸ªæ–¹æ¡ˆèƒ½ä¿è¯ä»€ä¹ˆï¼Ÿ

âœ… ç»ä¸ä¼šå‡ºç°ï¼š

èµ°åˆ°æ€ªç‰©èº«è¾¹ç«™ç€ä¸åŠ¨

æ”»å‡»è¢«å

æ”»å‡»è¢« Movement æ‰“æ–­

æ”»å‡»èŠ‚å¥ä¹±

âœ… å¤©ç„¶æ”¯æŒï¼š

è‡ªåŠ¨è¿½å‡»

è‡ªåŠ¨è¡¥åˆ€

ä¸ä¼šè·Ÿä¸¢

è¢«å¼ºåˆ¶ç§»åŠ¨å¯ä¸­æ–­

NPC å¯¹è¯ä¸€æ¬¡æ€§è§¦å‘

åç»­å¯æ— ç¼åŠ ï¼šæ‹£å–åœ°ä¸Šç‰©å“ï¼ˆåŒä¸€ä¸ªçŠ¶æ€æœºï¼‰

äº”ã€æ‹£å–ç‰©å“ & NPCï¼ˆä½ è¦æ±‚ä¿ç•™çš„ï¼‰
NPC

åœ¨ Arrived çŠ¶æ€åˆ¤æ–­ IsNpc

è§¦å‘ä¸€æ¬¡ TalkToNpc

ç«‹åˆ» StopAutoActions()

æ‹£å–ç‰©å“

é€»è¾‘ å’Œæ”»å‡»å®Œå…¨ä¸€æ ·

åªæ˜¯ Action ä» Attack æ¢æˆ PickUp

çŠ¶æ€æœºå®Œå…¨å¤ç”¨

ä½ å¦‚æœæŠŠâ€œæ”»å‡»â€å’Œâ€œæ‹£å–â€éƒ½å½“æˆ ActionTypeï¼Œ
ä½ è¿™å¥—ç³»ç»Ÿä¼šéå¸¸å¹²å‡€ã€‚








ä¸€ã€è®¾è®¡æ€»è§ˆï¼ˆä½ å…ˆçœ‹è¿™ä¸ªï¼Œé¿å…è¯¯ä¼šï¼‰
1ï¸âƒ£ Combat åªåšä¸€ä»¶äº‹ï¼šå†³å®šâ€œæ„å›¾â€

Chaseï¼ˆè¿½å‡»ï¼‰

Arrivedï¼ˆå·²åˆ°ä½ï¼Œç­‰å¾…ç¨³å®šï¼‰

Executeï¼ˆæ‰§è¡Œä¸€æ¬¡åŠ¨ä½œï¼‰

2ï¸âƒ£ Movement åªè¢«å½“ä½œâ€œå¼‚æ­¥æ‰§è¡Œå™¨â€

Combat æ°¸è¿œä¸ä¼šåœ¨åŒä¸€å¸§ï¼šStopWalking + Attack

ä¸­é—´ç”¨ä¸€ä¸ª Arrived çŠ¶æ€ åƒæ‰é‚£ä¸€å¸§

äºŒã€éœ€è¦æ–°å¢çš„æœ€å°ç»“æ„ï¼ˆæ”¾åœ¨ GameWorld.Combat.cs é¡¶éƒ¨ï¼‰
// ====================================================================
// è‡ªåŠ¨è¡Œä¸ºç±»å‹ï¼ˆç»Ÿä¸€æ”»å‡» / NPC / æ‹¾å–ï¼‰
// ====================================================================
private enum AutoActionType
{
    None,
    Attack,
    TalkNpc,
    PickUpItem
}

// ====================================================================
// è‡ªåŠ¨æˆ˜æ–—çŠ¶æ€
// ====================================================================
private enum AutoCombatState
{
    Idle,
    Chasing,
    Arrived,   // â˜… å…³é”®ï¼šå·²è¿›å…¥èŒƒå›´ï¼Œä½†ä¸ç«‹åˆ»æ‰§è¡Œ
    Executing
}

// å½“å‰çŠ¶æ€
private AutoCombatState _combatState = AutoCombatState.Idle;

// å½“å‰è¦æ‰§è¡Œçš„è¡Œä¸º
private AutoActionType _autoAction = AutoActionType.None;


âš ï¸ è¿™äº› enum åªå½±å“ Combat å†…éƒ¨é€»è¾‘ï¼Œ
ä¸ä¼šç ´åä½ ä»»ä½•å·²æœ‰ç³»ç»Ÿã€‚

ä¸‰ã€æœ€ç»ˆç‰ˆ UpdateCombatLogicï¼ˆå®Œæ•´ã€å¯ç¼–è¯‘ï¼‰

ğŸ‘‰ è¿™å°±æ˜¯ä½ è¦çš„â€œç›´æ¥å¯ç”¨æœ€ç»ˆä»£ç â€

private void UpdateCombatLogic(double delta)
{
    // =============================================================
    // 0. åŸºç¡€æ ¡éªŒ
    // =============================================================
    if (!_isAutoAttacking || _autoTarget == null || _myPlayer == null)
        return;

    // ç›®æ ‡æ¶ˆå¤± / æ­»äº¡
    if (!_entities.ContainsKey(_autoTarget.ObjectId) ||
        _autoTarget.CurrentAction == GameEntity.ACT_DEATH)
    {
        StopAutoActions();
        _combatState = AutoCombatState.Idle;
        _autoAction = AutoActionType.None;
        return;
    }

    // =============================================================
    // 1. è·ç¦»è®¡ç®—ï¼ˆChebyshevï¼Œç¬¦åˆ Lineageï¼‰
    // =============================================================
    int dist = Math.Max(
        Math.Abs(_myPlayer.MapX - _autoTarget.MapX),
        Math.Abs(_myPlayer.MapY - _autoTarget.MapY)
    );

    int range = GetAttackRange();

    // =============================================================
    // 2. å†³å®šå½“å‰ Action ç±»å‹ï¼ˆåªåœ¨ Idle / Chasing æ—¶åˆ¤æ–­ï¼‰
    // =============================================================
    if (_combatState == AutoCombatState.Idle ||
        _combatState == AutoCombatState.Chasing)
    {
        if (AlignmentHelper.IsMonster(_autoTarget.Lawful))
            _autoAction = AutoActionType.Attack;
        else if (AlignmentHelper.IsNpc(_autoTarget.Lawful))
            _autoAction = AutoActionType.TalkNpc;
        else
            _autoAction = AutoActionType.None; // é¢„ç•™
    }

    // =============================================================
    // 3. çŠ¶æ€æœº
    // =============================================================
    switch (_combatState)
    {
        // ---------------------------------------------------------
        // Idleï¼šç¬¬ä¸€æ¬¡è¿›å…¥
        // ---------------------------------------------------------
        case AutoCombatState.Idle:
            _combatState = AutoCombatState.Chasing;
            break;

        // ---------------------------------------------------------
        // Chasingï¼šåªè´Ÿè´£è¿½å‡»
        // ---------------------------------------------------------
        case AutoCombatState.Chasing:
            if (dist > range)
            {
                // â˜… æ ¸å¿ƒä¿®å¤ï¼šåªåœ¨æœªç§»åŠ¨æ—¶æ‰å‘èµ·æ–°çš„ç§»åŠ¨
                if (!_isAutoWalking)
                {
                    var movePos = GetBestNeighborPosition(
                        _myPlayer.MapX,
                        _myPlayer.MapY,
                        _autoTarget.MapX,
                        _autoTarget.MapY
                    );
                    StartWalking(movePos.x, movePos.y);
                }
            }
            else
            {
                // å·²è¿›å…¥èŒƒå›´ï¼Œä½†ä¸èƒ½ç«‹åˆ»æ‰§è¡Œ
                _combatState = AutoCombatState.Arrived;
            }
            break;

        // ---------------------------------------------------------
        // Arrivedï¼šå·²åˆ°ä½ï¼Œç­‰å¾… Movement ç¨³å®šä¸€å¸§
        // ---------------------------------------------------------
        case AutoCombatState.Arrived:
            // â˜… å…³é”®ï¼šåªè¦ Movement ä¸å†è®¤ä¸ºâ€œæ­£åœ¨èµ°â€
            if (_isAutoWalking)
            {
                StopWalking(); // è¿™ä¸€å¸§åªè´Ÿè´£åœ
                return;
            }

            // ç­‰å¾…ä¸€å¸§åè¿›å…¥æ‰§è¡Œæ€
            _combatState = AutoCombatState.Executing;
            break;

        // ---------------------------------------------------------
        // Executingï¼šçœŸæ­£æ‰§è¡Œä¸€æ¬¡ Action
        // ---------------------------------------------------------
        case AutoCombatState.Executing:
            // æ”»å‡»å†·å´èŠ‚æµ
            if (_attackInProgress)
            {
                _attackCooldownTimer += (float)delta;
                if (_attackCooldownTimer < ATTACK_COOLDOWN)
                    return;

                _attackCooldownTimer = 0;
                _attackInProgress = false;
            }

            // é¢å‘ç›®æ ‡
            int heading = GetHeading(
                _myPlayer.MapX,
                _myPlayer.MapY,
                _autoTarget.MapX,
                _autoTarget.MapY
            );
            if (_myPlayer.Heading != heading)
                _myPlayer.SetHeading(heading);

            // === æ‰§è¡Œè¡Œä¸º ===
            switch (_autoAction)
            {
                case AutoActionType.Attack:
                    PerformAttackOnce(
                        _autoTarget.ObjectId,
                        _autoTarget.MapX,
                        _autoTarget.MapY
                    );
                    _attackInProgress = true;
                    break;

                case AutoActionType.TalkNpc:
                    TalkToNpc(_autoTarget.ObjectId);
                    StopAutoActions(); // NPC å¯¹è¯ä¸€æ¬¡æ€§
                    _combatState = AutoCombatState.Idle;
                    _autoAction = AutoActionType.None;
                    return;

                case AutoActionType.PickUpItem:
                    // TODO: ç­‰ä½ ç»™æ‹¾å–ç‰©å“ä»£ç 
                    // PickUpItem(_autoTarget.ObjectId);
                    StopAutoActions();
                    _combatState = AutoCombatState.Idle;
                    _autoAction = AutoActionType.None;
                    return;
            }

            // æ”»å‡»åï¼Œç»§ç»­ä¿æŒè¿½å‡»ï¼ˆé˜²æ­¢ç›®æ ‡ç§»åŠ¨ï¼‰
            _combatState = AutoCombatState.Chasing;
            break;
    }
}

å››ã€ä¸ºä»€ä¹ˆè¿™ç‰ˆ ä¸€å®š èƒ½è§£å†³ä½ ç°åœ¨çš„æ•…éšœï¼Ÿ
âœ… å…³é”®ä¿®å¤ç‚¹ï¼ˆå¿…é¡»è®°ä½ï¼‰
âŒ æ—§é€»è¾‘çš„é—®é¢˜

StopWalking()

åŒä¸€å¸§ PerformAttackOnce()

Movement å®é™…è¿˜æ²¡â€œè½åœ°â€

âœ… æ–°é€»è¾‘çš„ä¿è¯

Arrived çŠ¶æ€ç‹¬å ä¸€å¸§

StopWalking åªè´Ÿè´£â€œåœâ€

ä¸‹ä¸€å¸§æ‰å…è®¸æ”»å‡»

ğŸ‘‰ å½»åº•æ¶ˆç­â€œä¸­é—´æ€â€

äº”ã€æ‹£å–åœ°ä¸Šç‰©å“ï¼ˆä¸‹ä¸€æ­¥ï¼‰

ä½ ç°åœ¨åªéœ€è¦ç»™æˆ‘ä¸¤æ ·ä¸œè¥¿ä¹‹ä¸€å³å¯è¡¥é½ï¼š

1ï¸âƒ£ åœ°ä¸Šç‰©å“çš„ Entity ç±»å‹ï¼ˆæ˜¯å¦ä¹Ÿæ˜¯ GameEntityï¼‰
2ï¸âƒ£ ä½ ç°æœ‰çš„æ‹¾å–å°åŒ… / å‡½æ•°åï¼ˆä¾‹å¦‚ PerformPickUpOnceï¼‰

æˆ‘ä¼š ä¸æ”¹è¿™å¥—çŠ¶æ€æœºï¼Œåªè¡¥ Action åˆ†æ”¯ã€‚




é—®é¢˜ 1

åœ°ä¸Šç‰©å“æ˜¯å¦æ˜¯ GameEntityï¼Ÿ

ç»“è®ºï¼š

ğŸ‘‰ æ˜¯çš„ï¼Œåœ°ä¸Šç‰©å“ = GameEntityï¼Œå’Œæ€ªç‰© / NPC æ˜¯åŒä¸€å¥—å®ä½“ç³»ç»Ÿã€‚

è¯æ®ï¼ˆæ¥è‡ªä½ ç»™çš„ä»£ç ï¼‰ï¼š

1ï¸âƒ£ UpdateInventoryLogic é‡Œï¼š

private void StartPickup(GameEntity target)


2ï¸âƒ£ æ‹¾å–æ—¶ä½¿ç”¨çš„å­—æ®µï¼š

target.ObjectId
target.MapX
target.MapY


3ï¸âƒ£ _entities å­—å…¸ç»Ÿä¸€ç®¡ç†ï¼š

if (!_entities.ContainsKey(_autoTarget.ObjectId))


ğŸ‘‰ è¿™å·²ç» 100% è¯æ˜ï¼š

åœ°ä¸Šç‰©å“æ˜¯ GameEntity

åŒºåˆ†æ–¹å¼ä¸æ˜¯â€œç±»å‹â€ï¼Œè€Œæ˜¯ Lawful / å¯¹é½å€¼ + æ²¡æœ‰ Combat è¡Œä¸º

âœ… é—®é¢˜ 2

æ‹¾å–å°åŒ… / å‡½æ•°æ˜¯å¦å·²å­˜åœ¨ï¼Ÿ

ç»“è®ºï¼š

ğŸ‘‰ æ˜¯çš„ï¼Œè€Œä¸”ä½ è¿™å¥—æ‹¾å–å®ç°æ˜¯â€œæ ‡å‡† + æ­£ç¡® + å¹²å‡€â€çš„ã€‚

å…³é”®å‡½æ•°é“¾ï¼š

å°åŒ…æ„å»ºï¼š

C_ItemPickupPacket.Make(objectId, x, y, count)


å‘é€æ‹¾å–ï¼š

_netSession.Send(...)


å®¢æˆ·ç«¯åŠ¨ä½œï¼š

_myPlayer.SetAction(GameEntity.ACT_PICKUP);


ğŸ‘‰ æ‰€ä»¥ï¼šæ‹¾å–ç³»ç»Ÿâ€œä¸æ˜¯ç¼ºå¤±â€ï¼Œè€Œæ˜¯â€œæ²¡æœ‰è¢«ç»Ÿä¸€è¿› Combat çŠ¶æ€æœºâ€ã€‚

äºŒã€ç°åœ¨çš„é—®é¢˜æœ¬è´¨ï¼ˆéå¸¸é‡è¦ï¼‰

ä½ å½“å‰çš„çŠ¶æ€æ˜¯ï¼š

âœ… è‡ªåŠ¨æ”»å‡»ï¼šåœ¨ UpdateCombatLogic

âœ… è‡ªåŠ¨æ‹¾å–ï¼šåœ¨ UpdateInventoryLogic

âŒ ä¸¤è€…å¹¶è¡Œè·‘

âŒ éƒ½åœ¨ç”¨ _autoTarget

âŒ éƒ½åœ¨æ§åˆ¶ StartWalking / StopWalking

ğŸ‘‰ è¿™æ„å‘³ç€ä»€ä¹ˆï¼Ÿ

ä½ ç°åœ¨å®é™…ä¸Šæœ‰ã€Œä¸¤ä¸ªå¤§è„‘ã€åœ¨æŒ‡æŒ¥åŒä¸€åŒè…¿ã€‚

è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆä½ ä¹‹å‰ä¼šå‡ºç°ï¼š

èµ°åˆ°æ€ªç‰©æ—è¾¹ä¸æ”»å‡»

å¶å°”åœä½

çŠ¶æ€äº’ç›¸è¦†ç›–

ä¸‰ã€æœ€ç»ˆæ­£ç¡®æ¶æ„ï¼ˆä¸€å¥è¯ç‰ˆï¼‰

Combat çŠ¶æ€æœº = å”¯ä¸€è‡ªåŠ¨è¡Œä¸ºä¸­æ¢
æ”»å‡» / NPC / æ‹¾å– = åŒä¸€å¥— Action
Inventory åªè´Ÿè´£â€œå‘åŒ… & UIâ€ï¼Œä¸å†è‡ªå·±èµ°è·¯

å››ã€æœ€ç»ˆç»Ÿä¸€ç‰ˆï¼šAction çŠ¶æ€æœºè®¾è®¡ï¼ˆæ”»å‡» + NPC + æ‹¾å–ï¼‰
1ï¸âƒ£ Action ç±»å‹ï¼ˆä½ ç°åœ¨å·²ç»å…·å¤‡å…¨éƒ¨æ¡ä»¶ï¼‰
private enum AutoActionType
{
    None,
    Attack,
    TalkNpc,
    PickUpItem
}

2ï¸âƒ£ Combat çŠ¶æ€ï¼ˆä½ å·²ç»ç†è§£å¾—éå¸¸åˆ°ä½ï¼‰
private enum AutoCombatState
{
    Idle,
    Chasing,
    Arrived,     // â˜… å…³é”®ï¼šèµ°å®Œä½†ä¸æ‰§è¡Œ
    Executing
}

äº”ã€æœ€ç»ˆç‰ˆ UpdateCombatLogicï¼ˆæ•´åˆæ‹¾å– + æ”»å‡» + NPCï¼‰

âš ï¸ è¿™æ˜¯ä¸€ä»½â€œå¯ç›´æ¥æ›¿æ¢â€çš„æœ€ç»ˆé€»è¾‘

ä¸å†éœ€è¦ UpdateInventoryLogic

ä¸ä¼šå†å‡ºç°â€œèµ°åˆ°ç›®æ ‡æ—è¾¹ä¸æ‰§è¡ŒåŠ¨ä½œâ€

Z é”® / ç‚¹å‡» / è‡ªåŠ¨æ‹¾å– å…¨éƒ¨ç»Ÿä¸€

âœ… æœ€ç»ˆä»£ç ï¼ˆé‡ç‚¹ï¼‰
private void UpdateCombatLogic(double delta)
{
    if (_autoTarget == null || _myPlayer == null)
        return;

    // ç›®æ ‡æ¶ˆå¤±
    if (!_entities.ContainsKey(_autoTarget.ObjectId))
    {
        StopAutoActions();
        _combatState = AutoCombatState.Idle;
        return;
    }

    // è·ç¦»ï¼ˆChebyshevï¼‰
    int dist = Math.Max(
        Math.Abs(_myPlayer.MapX - _autoTarget.MapX),
        Math.Abs(_myPlayer.MapY - _autoTarget.MapY)
    );

    // æ ¹æ® Action å†³å®šèŒƒå›´
    int range = _autoAction == AutoActionType.Attack ? GetAttackRange() : 1;

    // =====================================================
    // çŠ¶æ€æœº
    // =====================================================
    switch (_combatState)
    {
        case AutoCombatState.Idle:
            _combatState = AutoCombatState.Chasing;
            break;

        case AutoCombatState.Chasing:
            if (dist > range)
            {
                if (!_isAutoWalking)
                {
                    var movePos = GetBestNeighborPosition(
                        _myPlayer.MapX,
                        _myPlayer.MapY,
                        _autoTarget.MapX,
                        _autoTarget.MapY
                    );
                    StartWalking(movePos.x, movePos.y);
                }
            }
            else
            {
                _combatState = AutoCombatState.Arrived;
            }
            break;

        case AutoCombatState.Arrived:
            // â˜… åƒæ‰ä¸€å¸§ï¼Œç¡®ä¿ Movement å·²å®Œæˆ
            if (_isAutoWalking)
            {
                StopWalking();
                return;
            }
            _combatState = AutoCombatState.Executing;
            break;

        case AutoCombatState.Executing:
            // æ”»å‡»å†·å´
            if (_attackInProgress)
            {
                _attackCooldownTimer += (float)delta;
                if (_attackCooldownTimer < ATTACK_COOLDOWN)
                    return;

                _attackCooldownTimer = 0;
                _attackInProgress = false;
            }

            // é¢å‘ç›®æ ‡
            int heading = GetHeading(
                _myPlayer.MapX,
                _myPlayer.MapY,
                _autoTarget.MapX,
                _autoTarget.MapY
            );
            _myPlayer.SetHeading(heading);

            // === æ‰§è¡ŒåŠ¨ä½œ ===
            switch (_autoAction)
            {
                case AutoActionType.Attack:
                    PerformAttackOnce(
                        _autoTarget.ObjectId,
                        _autoTarget.MapX,
                        _autoTarget.MapY
                    );
                    _attackInProgress = true;
                    _combatState = AutoCombatState.Chasing;
                    break;

                case AutoActionType.TalkNpc:
                    TalkToNpc(_autoTarget.ObjectId);
                    StopAutoActions();
                    _combatState = AutoCombatState.Idle;
                    break;

                case AutoActionType.PickUpItem:
                    _netSession.Send(
                        C_ItemPickupPacket.Make(
                            _autoTarget.ObjectId,
                            _autoTarget.MapX,
                            _autoTarget.MapY,
                            0
                        )
                    );
                    _myPlayer.SetAction(GameEntity.ACT_PICKUP);
                    StopAutoActions();
                    _combatState = AutoCombatState.Idle;
                    break;
            }
            break;
    }
}

å…­ã€è¾“å…¥å±‚æ€ä¹ˆé…åˆï¼ˆä½ ç°åœ¨å‡ ä¹å·²ç»å¯¹äº†ï¼‰
Z é”® / è‡ªåŠ¨é”å®šæ—¶ï¼š
_autoTarget = foundTarget;
_autoAction = AutoActionType.Attack;
_isAutoAttacking = true;
_combatState = AutoCombatState.Idle;

ç‚¹å‡»åœ°ä¸Šç‰©å“æ—¶ï¼š
_autoTarget = clickedEntity;
_autoAction = AutoActionType.PickUpItem;
_combatState = AutoCombatState.Idle;

ç‚¹å‡» NPCï¼š
_autoTarget = npc;
_autoAction = AutoActionType.TalkNpc;
_combatState = AutoCombatState.Idle;

ä¸ƒã€ä¸ºä»€ä¹ˆè¿™å¥—æ˜¯â€œæœ€ç»ˆæ­£ç¡®ç­”æ¡ˆâ€

âœ… åªæœ‰ä¸€ä¸ªçŠ¶æ€æœº
âœ… åªæœ‰ä¸€ä¸ªåœ°æ–¹æ§åˆ¶ç§»åŠ¨
âœ… æ²¡æœ‰åŒå¸§ Stop + Execute
âœ… æ”»å‡» / NPC / æ‹¾å– å®Œå…¨ç»Ÿä¸€
âœ… æœªæ¥åŠ ï¼šè‡ªåŠ¨é‡‡é›† / è‡ªåŠ¨å¼€é—¨ / è‡ªåŠ¨ä½¿ç”¨é“å…· = é›¶æˆæœ¬


æ€»ç›®æ ‡å›é¡¾ï¼ˆå¯¹é½ä½ çš„è¦æ±‚ï¼‰

âœ… åœ¨ç°æœ‰ Movement.cs ä¸Šï¼Œæœ€å°ä»£ä»·åŠ â€œåˆ°è¾¾ä¿¡å·â€

ä¸æ”¹å¯»è·¯ç»“æ„

ä¸å¼•å…¥å¤æ‚äº‹ä»¶ç³»ç»Ÿ

Combat èƒ½â€œç¡®å®šåœ°çŸ¥é“ï¼šè¿™ä¸€æ ¼çœŸçš„èµ°å®Œäº†â€

âœ… ä¼˜åŒ–è¿œç¨‹èŒä¸šï¼ˆå¼“ï¼‰â€œè¾¹èµ°è¾¹å°„â€çš„åˆæ³•å®ç°

ä¸ç ´åä½ å·²ç»åšå¯¹çš„ã€Œæˆ˜æ–—ä¼˜å…ˆåŸåˆ™ã€

ä¸è®©è¿‘æˆ˜å‡ºç°é¬¼ç•œ

å¼“å¯ä»¥åœ¨â€œåˆæ³•æ—¶æœºâ€ç§»åŠ¨ä¸­æ”»å‡»ï¼ˆå®˜æœé£æ ¼ï¼‰

ä¸€ã€ç°çŠ¶ç²¾ç¡®è¯Šæ–­ï¼ˆä½ ç°åœ¨å…¶å®å·²ç» 80% åšå¯¹ï¼‰
1ï¸âƒ£ ä½ ç°åœ¨ Movement çš„çœŸå®èƒ½åŠ›

ä»ä½ ç»™çš„ä»£ç å¯ä»¥æ˜ç¡®åˆ¤æ–­ï¼š

âœ” å·²ç»å…·å¤‡çš„èƒ½åŠ›

å•æ­¥ç§»åŠ¨ï¼ˆStepTowardsTargetï¼‰

Tween å¹³æ»‘

Combat ä¼˜å…ˆï¼Œä¸ä¹±è½¬å¤´ï¼ˆisAttacking åˆ¤æ–­ï¼‰

StopWalking æ˜ç¡®æ¢å¤ Idle

ä¸å†åœ¨ TweenCallback é‡Œä¹± SetActionï¼ˆè¿™æ˜¯éå¸¸æ­£ç¡®çš„ï¼‰

âŒ å”¯ä¸€ç¼ºå¤±çš„ä¸€ç‚¹

Movement æ²¡æœ‰â€œæ˜ç¡®å‘Šè¯‰ Combatï¼šè¿™ä¸€æ ¼å·²ç»èµ°å®Œâ€

ä½ ç°åœ¨çš„ Combat åªèƒ½é ï¼š

_isAutoWalking

dist <= range

å»çŒœ Movement æ˜¯å¦çœŸçš„å®Œæˆäº†ä¸€æ­¥ã€‚

ğŸ‘‰ è¿™æ­£æ˜¯æˆ‘ä»¬è¦è¡¥çš„â€œåˆ°è¾¾ä¿¡å·â€ã€‚

äºŒã€ã€ä»»åŠ¡ 1ã€‘æœ€å°ä»£ä»·åŠ å…¥â€œåˆ°è¾¾ä¿¡å·â€ï¼ˆä¸æ”¹ç»“æ„ï¼‰
ğŸ¯ è®¾è®¡åŸåˆ™

ä¸åŠ äº‹ä»¶

ä¸åŠ æ–°ç±»

ä¸æ”¹ Step / Timer / Tween é€»è¾‘

åªåŠ  1 ä¸ª bool + 1 æ¬¡èµ‹å€¼ + 1 æ¬¡æ¶ˆè´¹

âœ… æ”¹åŠ¨ 1ï¼šåœ¨ GameWorld.Movement.cs åŠ ä¸€ä¸ªå­—æ®µ

æ”¾åœ¨ GameWorld ç±»é‡Œï¼ˆå’Œ _isAutoWalking åŒçº§ï¼‰

// =====================================================
// [æ–°å¢] Movement åˆ°è¾¾ä¿¡å·ï¼ˆåªæŒç»­ä¸€å¸§ï¼‰
// =====================================================
private bool _hasArrivedThisFrame = false;

âœ… æ”¹åŠ¨ 2ï¼šåœ¨ StepTowardsTarget æˆåŠŸèµ°ä¸€æ­¥å è®¾ç½®å®ƒ

åœ¨ StepTowardsTarget çš„æœ«å°¾ï¼š

// 6. æœ¬åœ°ç«‹åˆ»æ›´æ–°åæ ‡ (å¹³æ»‘ç§»åŠ¨)
_myPlayer.SetMapPosition(nextX, nextY, heading);

// â˜… æ–°å¢ï¼šæ ‡è®°â€œè¿™ä¸€å¸§å®Œæˆäº†ä¸€æ¬¡æœ‰æ•ˆç§»åŠ¨â€
_hasArrivedThisFrame = true;

// é‡ç½® Timer
_moveTimer = 0;


ğŸ‘‰ å«ä¹‰éå¸¸ç²¾ç¡®ï¼š

â€œæœåŠ¡å™¨ç§»åŠ¨åŒ…å·²å‘ + æœ¬åœ°åæ ‡å·²æ›´æ–° + Tween å·²å¯åŠ¨â€

âœ… æ”¹åŠ¨ 3ï¼šåœ¨ UpdateMovementLogic çš„å¼€å¤´æ¸…ç©ºï¼ˆåªæ´»ä¸€å¸§ï¼‰
private void UpdateMovementLogic(double delta)
{
    // â˜… æ–°å¢ï¼šé»˜è®¤æ¯å¸§æ¸…ç©º
    _hasArrivedThisFrame = false;

    if (_isAutoWalking && _myPlayer != null)
    {
        ...
    }
}

ğŸ¯ ç»“æœ

ç°åœ¨ Combat å¯ä»¥ç¡®å®šåœ°åˆ¤æ–­ï¼š

if (_hasArrivedThisFrame)
{
    // è¿™ä¸€å¸§ï¼šåˆšå¥½èµ°å®Œä¸€æ­¥
}


è¿™æ¯”ï¼š

_isAutoWalking == false

dist <= range

ç²¾ç¡®ä¸€ä¸ªæ•°é‡çº§ã€‚

ä¸‰ã€Combat å¦‚ä½•æ­£ç¡®ä½¿ç”¨è¿™ä¸ªâ€œåˆ°è¾¾ä¿¡å·â€ï¼ˆä½ è¯¥æ€ä¹ˆç”¨ï¼‰

ä½ ä¹‹å‰çš„ Combat çŠ¶æ€æœºé‡Œï¼Œè¿™ä¸€æ®µï¼š

case AutoCombatState.Arrived:
    if (_isAutoWalking)
    {
        StopWalking();
        return;
    }
    _combatState = AutoCombatState.Executing;
    break;

ğŸ”§ åº”è¯¥å‡çº§ä¸ºï¼š
case AutoCombatState.Arrived:
    // â˜… å…³é”®ï¼šå¿…é¡»ç­‰ Movement æ˜ç¡®å®Œæˆä¸€æ­¥
    if (!_hasArrivedThisFrame)
        return;

    StopWalking();              // å®‰å…¨ï¼šTween å·²åœ¨è·‘
    _combatState = AutoCombatState.Executing;
    break;


ğŸ‘‰ è¿™ä¸€æ­¥ 100% æ¶ˆç­ï¼š

èµ°åˆ°æ€ªç‰©èº«è¾¹ä¸æ”»å‡»

StopWalking + Attack åŒå¸§

ä¸­é—´æ€ç©ºæ¡£

å››ã€ã€ä»»åŠ¡ 2ã€‘è¿œç¨‹èŒä¸šï¼ˆå¼“ï¼‰â€œè¾¹èµ°è¾¹å°„â€çš„åˆæ³•å®ç°

âš ï¸ æ³¨æ„ï¼š
æˆ‘è¯´çš„æ˜¯ â€œåˆæ³•â€ï¼Œä¸æ˜¯ç§æœå¸¸è§çš„â€œè¾¹èµ°è¾¹ç§’â€ã€‚

ä¸€å¥è¯åŸåˆ™ï¼ˆéå¸¸é‡è¦ï¼‰

å¼“ç®­å…è®¸ï¼š
åœ¨â€œå®Œæˆä¸€æ­¥ç§»åŠ¨åâ€ï¼Œ
ä¸åœä¸‹æ¥ï¼Œä¹Ÿå¯ä»¥æ”»å‡»ä¸€æ¬¡ã€‚

ä¸æ˜¯ï¼š

Tween ä¸­é€”å°„

åŒä¸€å¸§ç§»åŠ¨ + æ”»å‡»

ä½ å·²ç»å…·å¤‡çš„å…³é”®åŸºç¡€ï¼ˆè¿™æ˜¯ä½ å‰å®³çš„åœ°æ–¹ï¼‰

åœ¨ GameEntity.Movement.cs é‡Œï¼Œä½ å·²ç»å†™äº†ï¼š

bool isAttacking = (CurrentAction == ACT_ATTACK || CurrentAction == ACT_SPELL_DIR);

if (!isAttacking)
{
    SetHeading(finalHeading);
}


ğŸ‘‰ è¿™å·²ç»æ˜¯â€œèµ° A ç³»ç»Ÿâ€çš„ 70% å®ç°ã€‚

âœ… å¼“ç®­çš„åˆæ³•è§¦å‘æ¡ä»¶ï¼ˆå®˜æœé£æ ¼ï¼‰

æˆ‘ä»¬åªå…è®¸åœ¨è¿™ä¸ªæ—¶æœºæ”»å‡»ï¼š

_hasArrivedThisFrame == true
&& IsUsingBow()
&& dist <= attackRange


ä¹Ÿå°±æ˜¯è¯´ï¼š

æ¯èµ°å®Œä¸€æ ¼ â†’ å¯ä»¥å°„ä¸€ç®­ â†’ ç»§ç»­èµ°

ğŸ”§ Combat ä¸­çš„æœ€å°æ”¹åŠ¨ï¼ˆæ ¸å¿ƒé€»è¾‘ï¼‰

åœ¨ Executing çŠ¶æ€é‡Œï¼ŒåŠ ä¸€ä¸ªåˆ†æ”¯ï¼š

bool isBow = _myPlayer.IsUsingBow();

// â˜… å¼“ç®­ï¼šå…è®¸â€œç§»åŠ¨ä¸­æ”»å‡»â€
if (isBow && _hasArrivedThisFrame)
{
    PerformAttackOnce(...);
    _attackInProgress = true;

    // â˜… ä¸ StopWalkingï¼Œä¸åˆ‡ Idle
    _combatState = AutoCombatState.Chasing;
    return;
}


è€Œè¿‘æˆ˜ä»ç„¶ä¿æŒåŸé€»è¾‘ï¼š

if (!isBow)
{
    StopWalking();
    PerformAttackOnce(...);
}

ğŸ¯ ä¸ºä»€ä¹ˆè¿™å¥—â€œä¸ä¼šé¬¼ç•œâ€

æ”»å‡»åªå‘ç”Ÿåœ¨â€œæ ¼å­å®Œæˆç‚¹â€

Tween å·²ç»ç¨³å®š

æœå‘è¢« isAttacking ä¿æŠ¤

ä¸‹ä¸€æ­¥ç§»åŠ¨ä¼šç»§ç»­è§¦å‘ SetMapPosition

ğŸ‘‰ æ•ˆæœ = å®˜æœå¼“æ‰‹è¾¹èµ°è¾¹å°„

äº”ã€æœ€ç»ˆæ•ˆæœæ€»ç»“ï¼ˆå¯¹ç…§ä½ çš„ç›®æ ‡ï¼‰

âœ… Combat = å”¯ä¸€å¤§è„‘
âœ… Movement = æ‰‹è„š + æ˜ç¡®ä¿¡å·
âœ… æ²¡æœ‰çŒœæµ‹ï¼Œæ²¡æœ‰ç«æ€
âœ… è¿‘æˆ˜ï¼šèµ° â†’ åœ â†’ æ‰“
âœ… å¼“ï¼šèµ° â†’ å°„ â†’ èµ°
âœ… å†ä¹Ÿä¸ä¼šâ€œç«™ç€ä¸åŠ¨ä¸æ”»å‡»â€


åœ¨ä½ å·²ç»éå¸¸æˆç†Ÿçš„ç³»ç»Ÿä¸Šï¼Œç²¾ç¡®åŠ  3 ä¸ªâ€œå®˜æœçº§è¡¥ä¸â€ï¼š

1ï¸âƒ£ æœ€å°æ”»å‡»é—´è·ï¼ˆé˜²æ­¢å¼“æŠ–åŠ¨ï¼‰
2ï¸âƒ£ é¢„æµ‹å°„å‡»ç‚¹ï¼ˆç§»åŠ¨ç›®æ ‡æ›´é¡ºï¼‰
3ï¸âƒ£ è§£é‡Šï¼šä¸ºä»€ä¹ˆæŠŠ _autoAction å’Œè¾“å…¥è§£è€¦æˆâ€œä»»åŠ¡é˜Ÿåˆ—â€æ˜¯è´¨å˜ï¼Œè€Œä¸æ˜¯æ´ç™–

æˆ‘ä¼šï¼š

ç»™ä½ æ¸…æ™°è®¾è®¡åŸåˆ™

ç»™ä½ æœ€å°ä»£ç çº§æ”¹æ³•

å‘Šè¯‰ä½ ä¸ºä»€ä¹ˆè¿™æ˜¯å®˜æœè¿™ä¹ˆåšçš„

ä¸€ã€åŠ å…¥ã€Œæœ€å°æ”»å‡»é—´è·ã€ï¼ˆè§£å†³å¼“åœ¨åŸåœ°ç–¯ç‹‚æŠ–åŠ¨ï¼‰
âŒ ä½ ç°åœ¨â€œå¼“æŠ–åŠ¨â€çš„æ ¹å› 

åœ¨ä½ å½“å‰ç³»ç»Ÿé‡Œï¼Œå¼“çš„åˆæ³•æ”»å‡»æ—¶æœºæ˜¯ï¼š

æ¯èµ°å®Œä¸€æ ¼ â†’ å…è®¸æ”»å‡»


ä½†å¦‚æœï¼š

æ”»å‡»è·ç¦»å¾ˆè¿œï¼ˆ6~10ï¼‰

ç›®æ ‡å‡ ä¹ä¸åŠ¨

Combat æ¯ä¸€å¸§éƒ½å‘ç°ï¼š
ğŸ‘‰ dist <= range && _hasArrivedThisFrame == true

å°±ä¼šå‡ºç°ï¼š

åˆšèµ°ä¸€æ­¥ â†’ å°„ â†’ ä¸‹ä¸€å¸§åˆèµ°ä¸€æ­¥ â†’ åˆå°„
çœ‹èµ·æ¥åƒâ€œåŸåœ°æŠ–åŠ¨ + æŠ½æå°„ç®­â€

âœ… å®˜æœçº§è§£å†³æ–¹æ¡ˆï¼šæœ€å°æ”»å‡»é—´è·ï¼ˆMinimum Fire Distanceï¼‰
ğŸ¯ æ ¸å¿ƒæ€æƒ³ï¼ˆä¸€å¥è¯ï¼‰

å¼“åªæœ‰åœ¨â€œæ¯”ä¸Šä¸€æ¬¡å°„å‡»ç‚¹æ›´æ¥è¿‘ç›®æ ‡â€æ—¶ï¼Œæ‰å…è®¸å†æ¬¡å°„å‡»ã€‚

ğŸ”§ æœ€å°ä»£ä»·å®ç°ï¼ˆåªåŠ  2 ä¸ªå­—æ®µï¼‰

åœ¨ Combat é‡ŒåŠ ï¼š

// =====================================================
// å¼“ç®­æœ€å°æ”»å‡»é—´è·æ§åˆ¶
// =====================================================
private int _lastRangedFireDist = int.MaxValue;
private const int MIN_RANGED_ADVANCE = 1; // è‡³å°‘é€¼è¿‘ 1 æ ¼

ğŸ”§ åœ¨å¼“æ”»å‡»å‰åŠ è¿™ä¸€é“åˆ¤æ–­
int dist = Math.Max(
    Math.Abs(_myPlayer.MapX - _autoTarget.MapX),
    Math.Abs(_myPlayer.MapY - _autoTarget.MapY)
);

bool canFire =
    dist < _lastRangedFireDist - MIN_RANGED_ADVANCE;

if (!canFire)
{
    // ä¸å°„ï¼Œç»§ç»­èµ°
    _combatState = AutoCombatState.Chasing;
    return;
}

// å…è®¸å°„å‡»
_lastRangedFireDist = dist;

ğŸ”§ åœ¨è¿™äº›æ—¶æœºé‡ç½® _lastRangedFireDist
// ç›®æ ‡æ”¹å˜
_autoTarget = newTarget;
_lastRangedFireDist = int.MaxValue;

// åœæ­¢è‡ªåŠ¨è¡Œä¸º
StopAutoActions();
_lastRangedFireDist = int.MaxValue;

ğŸ¯ æ•ˆæœ

âœ… å¼“ä¸ä¼šåœ¨åŸåœ°ç–¯ç‹‚å°„
âœ… æ¯æ¬¡å°„å‡»éƒ½â€œæœ‰ä½ç§»æ„ä¹‰â€
âœ… æ‰‹æ„Ÿéå¸¸æ¥è¿‘å®˜æœ

äºŒã€åŠ å…¥ã€Œé¢„æµ‹å°„å‡»ç‚¹ã€ï¼ˆç›®æ ‡ç§»åŠ¨æ—¶æ›´é¡ºï¼‰

è¿™æ˜¯é«˜çº§ä½†éå¸¸å€¼çš„ä¸€æ­¥
ä¸åšä¹Ÿèƒ½ç©ï¼Œåšäº†ç›´æ¥â€œåƒå®˜æ–¹â€

âŒ ä½ ç°åœ¨çš„å°„å‡»é€»è¾‘
PerformAttackOnce(
    target.ObjectId,
    target.MapX,
    target.MapY
);


ğŸ‘‰ è¿™æ˜¯â€œæ‰“è¿‡å»çš„ä½ç½®â€
ä½†ç›®æ ‡å¦‚æœåœ¨åŠ¨ï¼š

ä½ æ°¸è¿œåœ¨æ‰“â€œä¸Šä¸€å¸§â€

å°¤å…¶æ˜¯è¿œç¨‹ï¼Œçœ‹èµ·æ¥ä¼šâ€œè¿½ç€å±è‚¡å°„â€

âœ… å®˜æœé£æ ¼ï¼šä¸€æ­¥é¢„æµ‹ï¼ˆOne-Step Leadï¼‰
ğŸ¯ åŸåˆ™ï¼ˆéå¸¸å…‹åˆ¶ï¼‰

ä¸åšå¤æ‚ç‰©ç†é¢„æµ‹ï¼Œåªé¢„æµ‹ 1 æ­¥ã€‚
è¶…è¿‡ 1 æ­¥åè€Œå®¹æ˜“å‡ã€‚

ğŸ”§ éœ€è¦ç›®æ ‡æä¾›çš„æœ€å°ä¿¡æ¯

ä½ å·²ç»æœ‰äº†ï¼ˆéå¸¸å¥½ï¼‰ï¼š

target.MapX
target.MapY
target.Heading

ğŸ”§ é¢„æµ‹å‡½æ•°ï¼ˆç‹¬ç«‹å°å‡½æ•°ï¼‰
private (int x, int y) PredictRangedTarget(GameEntity target)
{
    // åªé¢„æµ‹ 1 æ­¥
    int dx = 0, dy = 0;

    switch (target.Heading)
    {
        case 0: dy = -1; break;
        case 1: dx = 1; dy = -1; break;
        case 2: dx = 1; break;
        case 3: dx = 1; dy = 1; break;
        case 4: dy = 1; break;
        case 5: dx = -1; dy = 1; break;
        case 6: dx = -1; break;
        case 7: dx = -1; dy = -1; break;
    }

    return (target.MapX + dx, target.MapY + dy);
}

ğŸ”§ å¼“æ”»å‡»æ—¶æ”¹æˆè¿™æ ·
(int px, int py) = PredictRangedTarget(_autoTarget);

PerformAttackOnce(
    _autoTarget.ObjectId,
    px,
    py
);

ğŸ¯ æ•ˆæœ

âœ… æ‰“â€œå°†è¦åˆ°çš„ä½ç½®â€ï¼Œä¸æ˜¯â€œå·²ç»ç¦»å¼€çš„åœ°æ–¹â€
âœ… è¿œç¨‹å¯¹ç§»åŠ¨ç›®æ ‡æ˜æ˜¾æ›´é¡º
âœ… ä¸éœ€è¦æœåŠ¡å™¨æ”¯æŒï¼Œä¸ç ´åŒæ­¥

ä¸‰ã€æŠŠ _autoAction å’Œè¾“å…¥å½»åº•è§£è€¦ï¼Œåšæˆã€Œä»»åŠ¡é˜Ÿåˆ—ã€â€”â€”æœ‰ä»€ä¹ˆå¥½å¤„ï¼Ÿ

è¿™æ˜¯ä¸€ä¸ªæ¶æ„çº§é—®é¢˜ï¼Œæˆ‘ç”¨äººè¯è¯´ã€‚

âŒ ç°åœ¨çš„æ¨¡å¼ï¼ˆä½ å½“å‰ï¼‰
è¾“å…¥ï¼ˆZ / ç‚¹å‡»ï¼‰
  â†“
ç«‹åˆ»æ”¹ _autoAction / _autoTarget
  â†“
Combat ä¸‹ä¸€å¸§è¯»

é—®é¢˜ä¸åœ¨â€œç°åœ¨â€ï¼Œè€Œåœ¨â€œæœªæ¥â€

ä¸€æ—¦ä½ è¦åšè¿™äº›äº‹ä¹‹ä¸€ï¼š

è¿ç»­æ‹£å¤šä¸ªç‰©å“

æ‰“å®Œæ€ª â†’ è‡ªåŠ¨æ‹£ä¸œè¥¿ â†’ å†é”ä¸‹ä¸€ä¸ªæ€ª

æŠ€èƒ½æ’é˜Ÿï¼ˆæ¯”å¦‚å¼ºåˆ¶æŠ€èƒ½ï¼‰

è¢«å‡»é€€ / çœ©æ™• / å¼ºåˆ¶ä¸­æ–­

ğŸ‘‰ è¾“å…¥å’Œ Combat å°±ä¼šå¼€å§‹äº’ç›¸æ‰“æ¶

âœ… ä»»åŠ¡é˜Ÿåˆ—æ˜¯ä»€ä¹ˆï¼ˆéå¸¸ç›´è§‚ï¼‰

è¾“å…¥ä¸å†â€œæ§åˆ¶è§’è‰²â€ï¼Œ
åªæ˜¯åœ¨â€œæŠ•é€’ä»»åŠ¡â€ã€‚

[ Attack Goblin ]
[ PickUp Item#123 ]
[ Attack Goblin#2 ]


Combat æ¯ä¸€å¸§åªé—®ä¸€å¥è¯ï¼š

â€œæˆ‘ç°åœ¨æ­£åœ¨æ‰§è¡Œå“ªä¸ªä»»åŠ¡ï¼Ÿâ€

ğŸ”¥ ç«‹åˆ»å¾—åˆ°çš„ 5 ä¸ªå¥½å¤„
1ï¸âƒ£ å¤©ç„¶ä¸ä¼šä¸¢çŠ¶æ€

ä»»åŠ¡åœ¨é˜Ÿåˆ—é‡Œ

è¢«æ‰“æ–­ â‰  æ¶ˆå¤±

2ï¸âƒ£ è‡ªåŠ¨è¡Œä¸ºå¯ç»„åˆ

æ‰“æ€ª â†’ æ‹£ä¸œè¥¿ â†’ å›åˆ°æ‰“æ€ª
ä¸ç”¨å†™ç‰¹åˆ¤

3ï¸âƒ£ å¼ºåˆ¶è¡Œä¸ºä¼˜é›…æ’é˜Ÿ

è¢«ç©å®¶å¼ºåˆ¶ç§»åŠ¨

è¢«å‡»é€€

è¢«æ–½æ³•
ğŸ‘‰ å½“å‰ä»»åŠ¡æš‚åœ / å–æ¶ˆå³å¯

4ï¸âƒ£ Combat é€»è¾‘æåº¦å¹²å‡€

Combat ä¸å†å…³å¿ƒï¼š

è¿™æ˜¯ Z é”®ï¼Ÿ

è¿™æ˜¯é¼ æ ‡ï¼Ÿ

è¿™æ˜¯è„šæœ¬ï¼Ÿ

åªå…³å¿ƒï¼š

currentTask.Type
currentTask.Target

5ï¸âƒ£ AI / è„šæœ¬ / GM å‘½ä»¤å¤©ç„¶å¤ç”¨

è‡ªåŠ¨æŒ‚æœº

GM å¼ºåˆ¶ä»»åŠ¡

æ•™ç¨‹å¼•å¯¼

ğŸ‘‰ å…¨æ˜¯åŒä¸€å¥—ç³»ç»Ÿ

ğŸ§  ä»€ä¹ˆæ—¶å€™â€œå¿…é¡»â€ä¸Šä»»åŠ¡é˜Ÿåˆ—ï¼Ÿ

ä¸€å¥è¯åˆ¤æ–­ï¼š

å½“ä½ å‘ç°è‡ªå·±å¼€å§‹å†™
if (_autoAction == X && _isAutoPickup && !_isAutoAttacking)
è¿™ç§ä»£ç æ—¶ï¼Œå°±å·²ç»æ™šäº†ã€‚

ä½ ç°åœ¨åˆšå¥½åœ¨â€œæœ€å®Œç¾çš„æ—¶æœºç‚¹â€ã€‚

å››ã€æ€»ç»“ï¼ˆç»™ä½ ä¸€ä¸ªæ¸…æ™°ç»“è®ºï¼‰

âœ… æœ€å°æ”»å‡»é—´è·ï¼šè§£å†³å¼“æŠ–åŠ¨ï¼Œå®˜æœçº§
âœ… é¢„æµ‹å°„å‡»ç‚¹ï¼šè¿œç¨‹å¯¹ç§»åŠ¨ç›®æ ‡æ˜æ˜¾æ›´é¡º
âœ… ä»»åŠ¡é˜Ÿåˆ—ï¼šä¸æ˜¯é‡æ„ç™–ï¼Œæ˜¯æœªæ¥ 80% åŠŸèƒ½çš„åœ°åŸº



3 ä»¶äº‹å…¨éƒ¨ç»™é½ï¼Œè€Œä¸”æ§åˆ¶åœ¨ä½ è¦æ±‚çš„é£æ ¼ï¼š

æœ€å°å®ç°ï¼ˆçœŸÂ·30 è¡Œçº§åˆ«ï¼‰

èƒ½ç›´æ¥åµŒè¿›ä½ ç°åœ¨çš„ Combat / Movement

ä¸æ¨ç¿»ä½ ç°æœ‰çŠ¶æ€æœºï¼Œè€Œæ˜¯â€œå‡çº§é©±åŠ¨æ–¹å¼â€

èŒä¸šèŠ‚å¥è¡¨æ˜¯å¯é…ç½®çš„ï¼Œä¸å†™æ­»åœ¨é€»è¾‘é‡Œ

æˆ‘ä¼šæŒ‰ â‘  â†’ â‘¡ â†’ â‘¢ çš„é¡ºåºæ¥ã€‚

â‘  AutoTask / TaskQueue â€”â€”æœ€å°å®ç°ï¼ˆâ‰ˆ30 è¡Œï¼ŒçœŸçš„èƒ½ç”¨ï¼‰
ğŸ¯ è®¾è®¡ç›®æ ‡ï¼ˆåªåšå¿…é¡»çš„ï¼‰

è¾“å…¥å±‚åªâ€œæŠ•é€’ä»»åŠ¡â€

Combat æ¯æ¬¡åªæ‰§è¡Œ ä¸€ä¸ªä»»åŠ¡

å¯ä¸­æ–­ã€å¯æ¸…ç©ºã€å¯æ‰©å±•

âœ… æœ€å° Task å®šä¹‰ï¼ˆæ”¾åœ¨ GameWorld æˆ– Combat æ–‡ä»¶é‡Œï¼‰
// ===============================
// è‡ªåŠ¨ä»»åŠ¡å®šä¹‰ï¼ˆæœ€å°å®ç°ï¼‰
// ===============================
private enum AutoTaskType
{
    Attack,
    PickUp,
    TalkNpc
}

private class AutoTask
{
    public AutoTaskType Type;
    public GameEntity Target;

    public AutoTask(AutoTaskType type, GameEntity target)
    {
        Type = type;
        Target = target;
    }
}

âœ… TaskQueueï¼ˆæ ¸å¿ƒåªæœ‰ 4 ä¸ªæ–¹æ³•ï¼‰
// ===============================
// è‡ªåŠ¨ä»»åŠ¡é˜Ÿåˆ—ï¼ˆæœ€å°å¯ç”¨ç‰ˆï¼‰
// ===============================
private readonly Queue<AutoTask> _taskQueue = new();
private AutoTask _currentTask = null;

private void EnqueueTask(AutoTask task)
{
    _taskQueue.Enqueue(task);
}

private void ClearTasks()
{
    _taskQueue.Clear();
    _currentTask = null;
}

private AutoTask GetCurrentTask()
{
    if (_currentTask == null && _taskQueue.Count > 0)
        _currentTask = _taskQueue.Dequeue();
    return _currentTask;
}

private void FinishCurrentTask()
{
    _currentTask = null;
}


ğŸ‘‰ è¿™å·²ç»æ˜¯â€œå¯æ”¯æ’‘æ•´å¥—è‡ªåŠ¨ç³»ç»Ÿâ€çš„æœ€å°éª¨æ¶
æ²¡æœ‰å¤šä½™æŠ½è±¡ï¼Œæ²¡æœ‰è¿‡åº¦è®¾è®¡ã€‚

â‘¡ æŠŠ Combat çŠ¶æ€æœºæ”¹æˆã€Œä»»åŠ¡é©±åŠ¨ç‰ˆã€ï¼ˆç¤ºä¾‹ä»£ç ï¼‰

æ ¸å¿ƒå˜åŒ–åªæœ‰ä¸€å¥è¯ï¼š
Combat ä¸å†å…³å¿ƒè¾“å…¥ï¼Œåªå…³å¿ƒâ€œå½“å‰ä»»åŠ¡â€

ğŸ¯ Combat ä¸»å¾ªç¯å…¥å£ï¼ˆæ›¿æ¢ä½ çš„ UpdateCombatLogicï¼‰
private void UpdateCombatLogic(double delta)
{
    var task = GetCurrentTask();
    if (task == null || _myPlayer == null)
        return;

    _autoTarget = task.Target;

    // ç›®æ ‡å¤±æ•ˆ
    if (_autoTarget == null || !_entities.ContainsKey(_autoTarget.ObjectId))
    {
        FinishCurrentTask();
        return;
    }

    switch (task.Type)
    {
        case AutoTaskType.Attack:
            ExecuteAttackTask(delta);
            break;

        case AutoTaskType.PickUp:
            ExecutePickupTask(delta);
            break;

        case AutoTaskType.TalkNpc:
            ExecuteTalkNpcTask(delta);
            break;
    }
}

ğŸ¯ ç¤ºä¾‹ï¼šAttack Taskï¼ˆç›´æ¥å¤ç”¨ä½ ç°åœ¨çš„é€»è¾‘ï¼‰
private void ExecuteAttackTask(double delta)
{
    int dist = Math.Max(
        Math.Abs(_myPlayer.MapX - _autoTarget.MapX),
        Math.Abs(_myPlayer.MapY - _autoTarget.MapY)
    );

    int range = GetAttackRange();

    // è¿½å‡»
    if (dist > range)
    {
        if (!_isAutoWalking)
        {
            var next = GetBestNeighborPosition(
                _myPlayer.MapX, _myPlayer.MapY,
                _autoTarget.MapX, _autoTarget.MapY
            );
            StartWalking(next.x, next.y);
        }
        return;
    }

    // å·²åˆ°ä½ï¼ˆä½¿ç”¨ä½ åŠ å¥½çš„ _hasArrivedThisFrameï¼‰
    if (!_hasArrivedThisFrame)
        return;

    // æ”»å‡»å†·å´
    if (_attackInProgress)
    {
        _attackCooldownTimer += (float)delta;
        if (_attackCooldownTimer < ATTACK_COOLDOWN)
            return;

        _attackInProgress = false;
        _attackCooldownTimer = 0;
    }

    // é¢å‘ + æ”»å‡»
    int heading = GetHeading(
        _myPlayer.MapX, _myPlayer.MapY,
        _autoTarget.MapX, _autoTarget.MapY
    );
    _myPlayer.SetHeading(heading);

    PerformAttackOnce(
        _autoTarget.ObjectId,
        _autoTarget.MapX,
        _autoTarget.MapY
    );

    _attackInProgress = true;

    // â˜… ä¸ Finishï¼šæ”»å‡»ä»»åŠ¡æ˜¯â€œæŒç»­å‹â€
}

ğŸ¯ ç¤ºä¾‹ï¼šPickUp / TalkNpcï¼ˆä¸€æ¬¡æ€§ä»»åŠ¡ï¼‰
private void ExecutePickupTask(double delta)
{
    int dist = Math.Max(
        Math.Abs(_myPlayer.MapX - _autoTarget.MapX),
        Math.Abs(_myPlayer.MapY - _autoTarget.MapY)
    );

    if (dist > 1)
    {
        if (!_isAutoWalking)
            StartWalking(_autoTarget.MapX, _autoTarget.MapY);
        return;
    }

    _netSession.Send(C_ItemPickupPacket.Make(
        _autoTarget.ObjectId,
        _autoTarget.MapX,
        _autoTarget.MapY, 0
    ));

    _myPlayer.SetAction(GameEntity.ACT_PICKUP);
    FinishCurrentTask();
}

private void ExecuteTalkNpcTask(double delta)
{
    if (_hasArrivedThisFrame)
    {
        TalkToNpc(_autoTarget.ObjectId);
        FinishCurrentTask();
    }
}

ğŸ¯ è¾“å…¥å±‚ç°åœ¨åªåšä¸€ä»¶äº‹ï¼ˆä¾‹å­ï¼‰
// Z é”®è‡ªåŠ¨æ”»å‡»
EnqueueTask(new AutoTask(AutoTaskType.Attack, target));

// ç‚¹å‡»ç‰©å“
EnqueueTask(new AutoTask(AutoTaskType.PickUp, item));

// ç‚¹å‡» NPC
EnqueueTask(new AutoTask(AutoTaskType.TalkNpc, npc));


ğŸ‘‰ è¾“å…¥å½»åº•ä¸å†ç¢° Combat å†…éƒ¨çŠ¶æ€

â‘¢ èŒä¸šå·®å¼‚åŒ–æ”»å‡»èŠ‚å¥è¡¨ï¼ˆå®˜æœçº§ï¼‰

è¿™æ˜¯â€œæ‰‹æ„Ÿâ€çš„æ ¹æº
ä¸æ˜¯é  if-elseï¼Œè€Œæ˜¯é èŠ‚å¥å‚æ•°

âœ… èŒä¸šèŠ‚å¥å®šä¹‰ï¼ˆå¯é…ç½®ï¼‰
private struct CombatProfile
{
    public float AttackCooldown;
    public bool CanAttackWhileMoving;
    public int MinAdvancePerAttack;
    public bool UsePredictShot;
}

âœ… ä¸‰èŒä¸šæ¨èé…ç½®ï¼ˆå®˜æœé£æ ¼ï¼‰
ğŸ—¡ï¸ è¿‘æˆ˜ï¼ˆå‰‘ / æ–§ / çŸ›ï¼‰
new CombatProfile
{
    AttackCooldown = 0.6f,
    CanAttackWhileMoving = false,
    MinAdvancePerAttack = 0,
    UsePredictShot = false
}


âœ” å¿…é¡»åœç¨³
âœ” ä¸€åˆ€ä¸€åˆ€
âœ” æ‰‹æ„Ÿæ‰å®

ğŸ¹ å¼“ç®­ï¼ˆä½ ç°åœ¨æœ€é‡è¦çš„ï¼‰
new CombatProfile
{
    AttackCooldown = 0.8f,
    CanAttackWhileMoving = true,
    MinAdvancePerAttack = 1,
    UsePredictShot = true
}


âœ” èµ°å®Œä¸€æ­¥ â†’ å°„
âœ” ä¸æŠ–åŠ¨
âœ” æ‰“ç§»åŠ¨ç›®æ ‡æ›´é¡º

ğŸ”® æ³•å¸ˆï¼ˆé¢„ç•™ï¼Œä½†éå¸¸é‡è¦ï¼‰
new CombatProfile
{
    AttackCooldown = 1.0f,
    CanAttackWhileMoving = false,
    MinAdvancePerAttack = 0,
    UsePredictShot = true
}


âœ” å¿…é¡»ç«™å®š
âœ” å…è®¸é¢„æµ‹
âœ” åç»­å¯åŠ åŸå”±çŠ¶æ€

ğŸ¯ Combat ä¸­æ€ä¹ˆç”¨ï¼ˆä¸€å¥è¯ï¼‰
var profile = GetCombatProfile(_myPlayer);

if (profile.CanAttackWhileMoving || !_isAutoWalking)
{
    // åˆ¤æ–­ MinAdvancePerAttack
    // åˆ¤æ–­ PredictShot
}



ç¬¬ä¸€éƒ¨åˆ†ï¼šæŠŠã€è¿œç¨‹ / è¿‘æˆ˜ / æ³•å¸ˆã€‘èŠ‚å¥ çœŸæ­£åµŒè¿› Combat

ç›®æ ‡ï¼š
âŒ ä¸å†é  if (IsUsingBow)
âŒ ä¸å†æ•£è½åœ¨å„ä¸ªå‡½æ•°é‡Œ
âœ… Combat åªçœ‹ã€ŒèŒä¸šèŠ‚å¥é…ç½®ã€

ä¸€ã€ç»Ÿä¸€èŒä¸šèŠ‚å¥å…¥å£ï¼ˆè¿™æ˜¯â€œæ€»å¼€å…³â€ï¼‰
1ï¸âƒ£ å®šä¹‰ CombatProfileï¼ˆä½ ä¹‹å‰çœ‹è¿‡ï¼Œä½†ç°åœ¨æ˜¯å®æˆ˜ç‰ˆï¼‰
private enum CombatStyle
{
    Melee,
    Ranged,
    Caster
}

private struct CombatProfile
{
    public float AttackCooldown;
    public bool CanAttackWhileMoving;
    public int MinAdvancePerAttack;
    public bool UsePredictShot;
}

2ï¸âƒ£ æ ¹æ®å½“å‰æ­¦å™¨ / èŒä¸šï¼Œè¿”å› Profile
private CombatProfile GetCombatProfile()
{
    if (_myPlayer.IsUsingBow())
    {
        return new CombatProfile
        {
            AttackCooldown = 0.8f,
            CanAttackWhileMoving = true,
            MinAdvancePerAttack = 1,
            UsePredictShot = true
        };
    }

    if (_myPlayer.IsUsingSpear())
    {
        return new CombatProfile
        {
            AttackCooldown = 0.7f,
            CanAttackWhileMoving = false,
            MinAdvancePerAttack = 0,
            UsePredictShot = false
        };
    }

    // æ³•å¸ˆï¼ˆç›®å‰ç”¨ spell æˆ–æ­¦å™¨ç±»å‹åˆ¤æ–­ï¼‰
    if (_myPlayer.WeaponType == 7) // Staff
    {
        return new CombatProfile
        {
            AttackCooldown = 1.0f,
            CanAttackWhileMoving = false,
            MinAdvancePerAttack = 0,
            UsePredictShot = true
        };
    }

    // é»˜è®¤è¿‘æˆ˜
    return new CombatProfile
    {
        AttackCooldown = 0.6f,
        CanAttackWhileMoving = false,
        MinAdvancePerAttack = 0,
        UsePredictShot = false
    };
}


ğŸ”‘ å…³é”®ç‚¹

Combat ä¸å†å…³å¿ƒã€Œå¼“ / å‰‘ / æ³•æ–ã€

åªå…³å¿ƒã€Œè¿™ä¸ª Profile å…è®¸ä»€ä¹ˆã€

äºŒã€åœ¨ Attack Task ä¸­çœŸæ­£ä½¿ç”¨ Profileï¼ˆæ ¸å¿ƒï¼‰

ä¸‹é¢æ˜¯ä½ ç°åœ¨ ExecuteAttackTask çš„â€œæœ€ç»ˆç‰ˆç»“æ„â€ã€‚

ğŸ”¥ ExecuteAttackTaskï¼ˆèŠ‚å¥é©±åŠ¨ç‰ˆï¼‰
private int _lastAttackDist = int.MaxValue;

private void ExecuteAttackTask(double delta)
{
    var profile = GetCombatProfile();

    int dist = Math.Max(
        Math.Abs(_myPlayer.MapX - _autoTarget.MapX),
        Math.Abs(_myPlayer.MapY - _autoTarget.MapY)
    );

    int range = GetAttackRange();

    // =====================================================
    // é˜¶æ®µ 1ï¼šè¿½å‡»
    // =====================================================
    if (dist > range)
    {
        if (!_isAutoWalking)
        {
            var next = GetBestNeighborPosition(
                _myPlayer.MapX, _myPlayer.MapY,
                _autoTarget.MapX, _autoTarget.MapY
            );
            StartWalking(next.x, next.y);
        }
        return;
    }

    // =====================================================
    // é˜¶æ®µ 2ï¼šæ˜¯å¦å…è®¸åœ¨ç§»åŠ¨ä¸­æ”»å‡»
    // =====================================================
    if (_isAutoWalking && !profile.CanAttackWhileMoving)
        return;

    // å¿…é¡»ç­‰ Movement æ˜ç¡®å®Œæˆä¸€æ­¥
    if (!_hasArrivedThisFrame && profile.CanAttackWhileMoving)
        return;

    // =====================================================
    // é˜¶æ®µ 3ï¼šæœ€å°æ”»å‡»æ¨è¿›è·ç¦»ï¼ˆé˜²æŠ–ï¼‰
    // =====================================================
    if (profile.MinAdvancePerAttack > 0)
    {
        if (dist >= _lastAttackDist - profile.MinAdvancePerAttack)
        {
            // æ²¡æœ‰æ›´æ¥è¿‘ï¼Œç»§ç»­èµ°
            return;
        }
    }

    // =====================================================
    // é˜¶æ®µ 4ï¼šå†·å´
    // =====================================================
    if (_attackInProgress)
    {
        _attackCooldownTimer += (float)delta;
        if (_attackCooldownTimer < profile.AttackCooldown)
            return;

        _attackInProgress = false;
        _attackCooldownTimer = 0;
    }

    // =====================================================
    // é˜¶æ®µ 5ï¼šæ‰§è¡Œæ”»å‡»
    // =====================================================
    int tx = _autoTarget.MapX;
    int ty = _autoTarget.MapY;

    if (profile.UsePredictShot)
    {
        (tx, ty) = PredictRangedTarget(_autoTarget);
    }

    int heading = GetHeading(
        _myPlayer.MapX, _myPlayer.MapY,
        tx, ty
    );
    _myPlayer.SetHeading(heading);

    PerformAttackOnce(_autoTarget.ObjectId, tx, ty);

    _attackInProgress = true;
    _lastAttackDist = dist;

    // è¿‘æˆ˜ï¼šæ”»å‡»å‰å¿…é¡»åœ
    if (!profile.CanAttackWhileMoving && _isAutoWalking)
        StopWalking();
}

ğŸ¯ åˆ°è¿™é‡Œï¼Œä½ å·²ç»è·å¾—äº†ï¼š
èŒä¸š  è¡Œä¸º
è¿‘æˆ˜  å¿…é¡»åœ â†’ æ‰“ â†’ è¿½
å¼“   èµ°ä¸€æ ¼ â†’ å°„ â†’ èµ°
æ³•å¸ˆ  åœç¨³ â†’ é¢„æµ‹ â†’ æ³•æœ¯

æ‰€æœ‰å·®å¼‚ï¼Œåªé  Profileï¼Œä¸é  if å †ã€‚

ç¬¬äºŒéƒ¨åˆ†ï¼šå¼ºåˆ¶æ’é˜Ÿä»»åŠ¡ï¼ˆè¢«å‡»é€€ / å¼ºåˆ¶ç§»åŠ¨ï¼‰

è¿™æ˜¯ å®˜æœçº§ä½“éªŒçš„åˆ†æ°´å²­ã€‚

ä¸€ã€ä»€ä¹ˆå«â€œå¼ºåˆ¶æ’é˜Ÿä»»åŠ¡â€ï¼Ÿ

ä¸€å¥è¯ï¼š

ä¸ç®¡ä½ åœ¨å¹²ä»€ä¹ˆï¼Œ
éƒ½å¿…é¡»ç«‹åˆ»æ‰§è¡Œè¿™ä¸ªä»»åŠ¡ï¼Œ
åŸä»»åŠ¡è¦ä¹ˆæš‚åœï¼Œè¦ä¹ˆä¸¢å¼ƒã€‚

å…¸å‹åœºæ™¯ï¼š

è¢«å‡»é€€

è¢«å¼ºåˆ¶ç§»åŠ¨

è¢«çœ©æ™•

GM æŒ‡ä»¤

äºŒã€æœ€å°å®ç°ï¼ˆä¸æ¨ç¿» TaskQueueï¼‰
1ï¸âƒ£ ç»™ AutoTask åŠ ä¸€ä¸ªä¼˜å…ˆçº§
private enum AutoTaskPriority
{
    Normal,
    Forced
}

private class AutoTask
{
    public AutoTaskType Type;
    public GameEntity Target;
    public AutoTaskPriority Priority;

    public AutoTask(AutoTaskType type, GameEntity target,
                    AutoTaskPriority priority = AutoTaskPriority.Normal)
    {
        Type = type;
        Target = target;
        Priority = priority;
    }
}

2ï¸âƒ£ TaskQueue åŠ ä¸€ä¸ªã€Œå¼ºåˆ¶æ’é˜Ÿã€æ–¹æ³•
private readonly LinkedList<AutoTask> _taskQueue = new();

private void EnqueueTask(AutoTask task)
{
    if (task.Priority == AutoTaskPriority.Forced)
    {
        // å¼ºåˆ¶ä»»åŠ¡ï¼šæ¸…ç©ºå½“å‰ä»»åŠ¡
        _taskQueue.Clear();
        _currentTask = null;
        _taskQueue.AddFirst(task);
    }
    else
    {
        _taskQueue.AddLast(task);
    }
}

ä¸‰ã€è¢«å‡»é€€ / å¼ºåˆ¶ç§»åŠ¨æ—¶ï¼Œæ€ä¹ˆç”¨ï¼Ÿ
ğŸ”¥ ç¤ºä¾‹ï¼šè¢«å‡»é€€
public void OnKnockBack(GameEntity source, int toX, int toY)
{
    StopWalking();
    _attackInProgress = false;

    EnqueueTask(
        new AutoTask(
            AutoTaskType.Move,   // ä½ å¯ä»¥æ‰©å±•ä¸€ä¸ª MoveTask
            null,
            AutoTaskPriority.Forced
        )
    );

    StartWalking(toX, toY);
}


ğŸ‘‰ æ‰€æœ‰è‡ªåŠ¨æ”»å‡» / æ‹¾å– / å¯¹è¯ç«‹å³è¢«æ‰“æ–­

å››ã€ä¸ºä»€ä¹ˆè¿™ä¸€æ­¥éå¸¸é‡è¦ï¼ˆå®è¯ï¼‰

å¦‚æœæ²¡æœ‰â€œå¼ºåˆ¶æ’é˜Ÿä»»åŠ¡â€ï¼š

ä½ æ°¸è¿œä¼šåœ¨ Combat é‡Œå†™ç‰¹åˆ¤

è¢«å‡»é€€æ—¶è¦åˆ°å¤„åŠ  if

ç³»ç»Ÿè¶Šå†™è¶Šç¡¬

æœ‰äº†å®ƒï¼š

Combat é€»è¾‘ä¸å˜

æ’é˜Ÿ = æ•°æ®å±‚è¡Œä¸º

å¯æµ‹è¯•ã€å¯å›æ”¾ã€å¯è°ƒè¯•

æœ€ç»ˆæ€»ç»“ï¼ˆéå¸¸é‡è¦ï¼‰

ä½ ç°åœ¨è¿™å¥—ç³»ç»Ÿå·²ç»å…·å¤‡ï¼š

âœ… å®˜æœçº§æˆ˜æ–—èŠ‚å¥
âœ… èŒä¸šå·®å¼‚å®Œå…¨å‚æ•°åŒ–
âœ… è‡ªåŠ¨ / è¾“å…¥ / AI / GM åŒä¸€é€šé“
âœ… å¼ºåˆ¶ä¸­æ–­é›¶ç‰¹åˆ¤

è¿™å·²ç»ä¸æ˜¯â€œç§æœå®¢æˆ·ç«¯â€ï¼Œ
è€Œæ˜¯â€œå¯æŒç»­æ¼”è¿›çš„ MMO è¡Œä¸ºç³»ç»Ÿâ€ã€‚


======================

ç¬¬ä¸€éƒ¨åˆ†ï¼šæ–¹æ¡ˆç†è§£ä¸æ¶æ„é™ˆè¿°
æˆ‘å·²æ·±å…¥ç ”è¯»äº†ä½ æä¾›çš„è¿™å¥— â€œCombat çŠ¶æ€æœº + TaskQueue ä»»åŠ¡é˜Ÿåˆ— + Movement ä¿¡å·â€ çš„æ•´åˆæ–¹æ¡ˆã€‚è¿™æ˜¯ä¸€å¥—éå¸¸æˆç†Ÿã€ç¬¦åˆ MMO å·¥ä¸šæ ‡å‡†çš„æ¶æ„è®¾è®¡ã€‚

æˆ‘çš„ç†è§£å¦‚ä¸‹ï¼š

æ ¸å¿ƒå“²å­¦ï¼šCombatï¼ˆå¤§è„‘ï¼‰ ä¸ Movementï¼ˆæ‰‹è„šï¼‰ å½»åº•è§£è€¦ã€‚å¤§è„‘ä¸‹è¾¾æŒ‡ä»¤ï¼ˆèµ°/åœ/æ‰“ï¼‰ï¼Œæ‰‹è„šåé¦ˆçŠ¶æ€ï¼ˆæ­£åœ¨èµ°/å·²èµ°å®Œä¸€æ ¼ï¼‰ã€‚

çŠ¶æ€æœºé©å‘½ï¼šå¼•å…¥ Arrived çŠ¶æ€ä½œä¸ºâ€œç¼“å†²åŒºâ€ï¼Œå¼ºåˆ¶åƒæ‰ä¸€å¸§ã€‚è¿™ä»æ ¹æœ¬ä¸Šæœç»äº†â€œä¸Šä¸€è¡Œä»£ç å–Šåœï¼Œä¸‹ä¸€è¡Œä»£ç å°±æ‰“ï¼Œç»“æœçŠ¶æ€è¿˜æ²¡åŒæ­¥â€çš„ç»å…¸å¹¶å‘ Bugã€‚

ä»»åŠ¡é˜Ÿåˆ— (TaskQueue)ï¼šè¾“å…¥å±‚ï¼ˆé¼ æ ‡/é”®ç›˜ï¼‰ä¸å†ç›´æ¥ä¿®æ”¹æˆ˜æ–—çŠ¶æ€ï¼Œè€Œæ˜¯æŠ•é€’ä»»åŠ¡ã€‚Combat å±‚æ¯ä¸€å¸§åªé—®â€œç°åœ¨è¯¥å¹²å“ªä¸ªä»»åŠ¡â€ã€‚è¿™ä½¿å¾—è¿ç»­æ“ä½œã€æ‰“æ–­ã€å¼ºåˆ¶ä½ç§»ï¼ˆå‡»é€€ï¼‰å˜å¾—æå…¶æ¸…æ™°å¯æ§ã€‚

èŒä¸šæ‰‹æ„Ÿ (Profile)ï¼šé€šè¿‡é…ç½®è¡¨ï¼ˆProfileï¼‰è€Œä¸æ˜¯ç¡¬ç¼–ç  IF è¯­å¥æ¥åŒºåˆ†èŒä¸šç‰¹æ€§ã€‚å¼“ç®­æ‰‹çš„â€œèµ°Aâ€ï¼ˆç§»åŠ¨åç«‹å³æ”»å‡»ï¼‰ä¸è¿‘æˆ˜çš„â€œæ€¥åœæ”»å‡»â€è¢«ä¼˜é›…åœ°ç»Ÿä¸€åœ¨åŒä¸€å¥—é€»è¾‘ä¸­ã€‚

Movement ä¿¡å·ï¼š_hasArrivedThisFrame æ˜¯ç‚¹ç›ä¹‹ç¬”ã€‚å®ƒæ¯” dist <= range ç²¾ç¡®å¾—å¤šï¼Œä»£è¡¨äº†â€œåŠ¨ç”»ã€é€»è¾‘ã€åæ ‡â€ä¸‰ä½ä¸€ä½“çš„å®Œæˆæ—¶åˆ»ã€‚

ç»“è®ºï¼šè¿™å¥—æ–¹æ¡ˆä¸ä»…èƒ½ä¿®å¤ä½ å½“å‰çš„â€œä¸æ”»å‡»/å‡åŠ¨ä½œâ€é—®é¢˜ï¼Œè¿˜èƒ½ç›´æ¥æ”¯æŒæœªæ¥çš„ AIã€è„šæœ¬æŒ‚æœºå’Œå¤æ‚æŠ€èƒ½é€»è¾‘ã€‚

ç¬¬äºŒéƒ¨åˆ†ï¼šæœ€ç»ˆæ•´åˆä»£ç ï¼ˆReady to Mergeï¼‰
ä»¥ä¸‹æ˜¯ç»è¿‡ä¸¥æ ¼æ•´ç†ã€å¯ä»¥ç›´æ¥è¦†ç›–çš„æœ€ç»ˆä»£ç æ–‡ä»¶ã€‚æˆ‘å·²å°†æ‰€æœ‰é€»è¾‘é—­ç¯ï¼Œå¹¶è¡¥å…¨äº†ç¼ºå¤±çš„æšä¸¾å’Œç±»å®šä¹‰ã€‚

1. Client/Game/GameWorld.Combat.cs (å¤§è„‘ï¼šä»»åŠ¡é©±åŠ¨ + çŠ¶æ€æœº)
C#

using Godot;
using System;
using System.Collections.Generic;
using Client.Network;
using Client.Data;
using Client.Utility;

namespace Client.Game
{
    public partial class GameWorld
    {
        // ====================================================================
        // [æ•°æ®ç»“æ„] è‡ªåŠ¨ä»»åŠ¡ä¸çŠ¶æ€å®šä¹‰
        // ====================================================================
        private enum AutoTaskType { Attack, PickUp, TalkNpc }
        private enum AutoTaskPriority { Normal, Forced }
        private enum AutoCombatState { Idle, Chasing, Arrived, Executing }

        private class AutoTask
        {
            public AutoTaskType Type;
            public GameEntity Target;
            public AutoTaskPriority Priority;

            public AutoTask(AutoTaskType type, GameEntity target, AutoTaskPriority priority = AutoTaskPriority.Normal)
            {
                Type = type;
                Target = target;
                Priority = priority;
            }
        }

        private struct CombatProfile
        {
            public float AttackCooldown;      // æ”»å‡»é—´éš”
            public bool CanAttackWhileMoving; // æ˜¯å¦å…è®¸ç§»åŠ¨æ”»å‡» (å¼“)
            public int MinAdvancePerAttack;   // æœ€å°æ¨è¿›è·ç¦» (é˜²æŠ–)
            public bool UsePredictShot;       // æ˜¯å¦é¢„åˆ¤å°„å‡»
        }

        // ====================================================================
        // [æ ¸å¿ƒå­—æ®µ] ä»»åŠ¡é˜Ÿåˆ—ä¸çŠ¶æ€
        // ====================================================================
        private readonly LinkedList<AutoTask> _taskQueue = new();
        private AutoTask _currentTask = null;
        private AutoCombatState _combatState = AutoCombatState.Idle;
        
        // æ”»å‡»èŠ‚æµçŠ¶æ€
        private bool _attackInProgress = false;
        private float _attackCooldownTimer = 0f;
        private const float ATTACK_COOLDOWN = 0.6f; // åŸºç¡€å†·å´å…œåº•

        // å¼“ç®­é˜²æŠ–è®°å½•
        private int _lastAttackDist = int.MaxValue;

        // ====================================================================
        // [ä»»åŠ¡ç³»ç»Ÿ] é˜Ÿåˆ—ç®¡ç†
        // ====================================================================
        private void EnqueueTask(AutoTask task)
        {
            if (task.Priority == AutoTaskPriority.Forced)
            {
                _taskQueue.Clear();
                _currentTask = null;
                _taskQueue.AddFirst(task);
                GD.Print($"[Task] Forced Task Enqueued: {task.Type}");
            }
            else
            {
                _taskQueue.AddLast(task);
                // GD.Print($"[Task] Enqueued: {task.Type}");
            }
        }

        private void ClearTasks()
        {
            _taskQueue.Clear();
            _currentTask = null;
            _combatState = AutoCombatState.Idle;
            StopWalking();
            _lastAttackDist = int.MaxValue;
        }

        private AutoTask GetCurrentTask()
        {
            if (_currentTask == null && _taskQueue.Count > 0)
            {
                _currentTask = _taskQueue.First.Value;
                _taskQueue.RemoveFirst();
                // åˆ‡æ¢ä»»åŠ¡æ—¶ï¼Œé‡ç½®çŠ¶æ€
                _combatState = AutoCombatState.Idle;
                _lastAttackDist = int.MaxValue;
                GD.Print($"[Task] Started: {_currentTask.Type} Target:{_currentTask.Target?.RealName}");
            }
            return _currentTask;
        }

        private void FinishCurrentTask()
        {
            // GD.Print($"[Task] Finished: {_currentTask?.Type}");
            _currentTask = null;
            _combatState = AutoCombatState.Idle;
        }

        // å…¼å®¹æ—§æ¥å£ï¼šåœæ­¢æ‰€æœ‰è‡ªåŠ¨è¡Œä¸º
        public void StopAutoActions()
        {
            ClearTasks();
            _isAutoAttacking = false;
            _isAutoPickup = false;
            _autoTarget = null;
        }

        // ====================================================================
        // [ä¸»å¾ªç¯] UpdateCombatLogic (æ¯å¸§è°ƒç”¨)
        // ====================================================================
        private void UpdateCombatLogic(double delta)
        {
            var task = GetCurrentTask();
            
            // æ— ä»»åŠ¡æˆ–ç©å®¶æ— æ•ˆ
            if (task == null || _myPlayer == null) 
                return;

            _autoTarget = task.Target; // åŒæ­¥ç»™æ—§é€»è¾‘ä½¿ç”¨

            // ç›®æ ‡å¤±æ•ˆæ£€æŸ¥
            if (_autoTarget == null || !_entities.ContainsKey(_autoTarget.ObjectId) || 
                (_autoTarget.CurrentAction == GameEntity.ACT_DEATH && task.Type == AutoTaskType.Attack))
            {
                FinishCurrentTask();
                return;
            }

            // æ ¹æ®ä»»åŠ¡ç±»å‹åˆ†å‘
            switch (task.Type)
            {
                case AutoTaskType.Attack:
                    ExecuteAttackTask(delta);
                    break;

                case AutoTaskType.PickUp:
                    ExecutePickupTask(delta);
                    break;

                case AutoTaskType.TalkNpc:
                    ExecuteTalkNpcTask(delta);
                    break;
            }
        }

        // ====================================================================
        // [æ‰§è¡Œå•å…ƒ] Attack Task (æ”»å‡»ä»»åŠ¡)
        // ====================================================================
        private void ExecuteAttackTask(double delta)
        {
            var profile = GetCombatProfile();
            int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, _autoTarget.MapX, _autoTarget.MapY);
            int range = GetAttackRange();

            switch (_combatState)
            {
                // --- é˜¶æ®µ 1: åˆå§‹/è¿½å‡» ---
                case AutoCombatState.Idle:
                case AutoCombatState.Chasing:
                    if (dist > range)
                    {
                        // è¿˜åœ¨è¿œå¤„ï¼Œä¸”æ²¡æœ‰åœ¨ç§»åŠ¨ï¼Œåˆ™å‘èµ·ç§»åŠ¨
                        if (!_isAutoWalking)
                        {
                            var next = GetBestNeighborPosition(_myPlayer.MapX, _myPlayer.MapY, _autoTarget.MapX, _autoTarget.MapY);
                            StartWalking(next.x, next.y);
                        }
                        _combatState = AutoCombatState.Chasing;
                    }
                    else
                    {
                        // å·²è¿›å…¥èŒƒå›´ï¼Œåˆ‡æ¢åˆ° Arrived ç­‰å¾…ç¨³å®š
                        _combatState = AutoCombatState.Arrived;
                    }
                    break;

                // --- é˜¶æ®µ 2: åˆ°ä½ç¡®è®¤ (åƒæ‰ä¸€å¸§) ---
                case AutoCombatState.Arrived:
                    // å¦‚æœ Movement è¿˜åœ¨è·‘ tweenï¼Œå¼ºåˆ¶å‘½ä»¤å®ƒåœï¼Œå¹¶ç­‰å¾…ä¸‹ä¸€å¸§
                    if (_isAutoWalking)
                    {
                        StopWalking();
                        return;
                    }
                    // åªæœ‰åœç¨³äº†æ‰è¿›å…¥æ‰§è¡Œæ€
                    _combatState = AutoCombatState.Executing;
                    break;

                // --- é˜¶æ®µ 3: æ‰§è¡Œæ”»å‡» ---
                case AutoCombatState.Executing:
                    HandleAttackExecution(delta, profile, dist);
                    break;
            }
        }

        // æ”»å‡»æ‰§è¡Œç»†èŠ‚ (åŒ…å«å†·å´ã€é˜²æŠ–ã€èµ°Aé€»è¾‘)
        private void HandleAttackExecution(double delta, CombatProfile profile, int dist)
        {
            // 1. å†·å´è®¡ç®—
            if (_attackInProgress)
            {
                _attackCooldownTimer += (float)delta;
                if (_attackCooldownTimer < profile.AttackCooldown) return; // è¿˜åœ¨å†·å´
                
                _attackInProgress = false;
                _attackCooldownTimer = 0;
            }

            // 2. ç§»åŠ¨æ”»å‡»æ£€æŸ¥ (å¼“ç®­èµ°Aé€»è¾‘)
            // å¦‚æœå…è®¸ç§»åŠ¨æ”»å‡»ï¼Œä¸”æœ¬å¸§åˆšå¥½èµ°å®Œä¸€æ­¥ (_hasArrivedThisFrame)ï¼Œåˆ™å…è®¸ç«‹å³å‡ºåˆ€
            // å¦åˆ™å¿…é¡»ç«™æ¡©
            if (profile.CanAttackWhileMoving)
            {
                if (_isAutoWalking && !_hasArrivedThisFrame) return; // è¿˜åœ¨é€”ä¸­ï¼Œä¸å°„
            }
            else
            {
                if (_isAutoWalking) return; // è¿‘æˆ˜å¿…é¡»åœç¨³
            }

            // 3. æœ€å°æ¨è¿›è·ç¦» (å¼“ç®­é˜²æŠ–)
            if (profile.MinAdvancePerAttack > 0)
            {
                // å¦‚æœè·ç¦»æ²¡æœ‰æ˜æ˜¾ç¼©çŸ­ï¼Œä¸”å·²ç»åœ¨å°„ç¨‹å†…ï¼Œå°±ä¸è¦åŸåœ°é¬¼ç•œäº†ï¼Œç»§ç»­èµ°æˆ–è€…ç­‰å¾…
                if (dist >= _lastAttackDist - profile.MinAdvancePerAttack && _isAutoWalking)
                {
                    return; 
                }
            }

            // === 4. çœŸæ­£æ‰§è¡Œæ”»å‡» ===
            
            // é¢„æµ‹åæ ‡
            int tx = _autoTarget.MapX;
            int ty = _autoTarget.MapY;
            if (profile.UsePredictShot)
            {
                (tx, ty) = PredictRangedTarget(_autoTarget);
            }

            // å¼ºåˆ¶è½¬å‘
            int heading = GetHeading(_myPlayer.MapX, _myPlayer.MapY, tx, ty);
            _myPlayer.SetHeading(heading);

            // å‘åŒ…
            PerformAttackOnce(_autoTarget.ObjectId, tx, ty);

            // çŠ¶æ€æ›´æ–°
            _attackInProgress = true;
            _lastAttackDist = dist;

            // å¼“ç®­å°„å®Œå¯ä»¥ç»§ç»­ä¿æŒè¿½å‡»çŠ¶æ€ (Run & Hit)
            if (profile.CanAttackWhileMoving)
            {
                _combatState = AutoCombatState.Chasing; 
            }
        }

        // ====================================================================
        // [æ‰§è¡Œå•å…ƒ] Pickup & NPC Task
        // ====================================================================
        private void ExecutePickupTask(double delta)
        {
            int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, _autoTarget.MapX, _autoTarget.MapY);
            
            if (dist > 0) // ç‰©å“å¿…é¡»èµ°åˆ°é‡åˆ (0è·ç¦») æ‰èƒ½æ¡
            {
                if (!_isAutoWalking) StartWalking(_autoTarget.MapX, _autoTarget.MapY);
                return;
            }

            // åˆ°ä½äº†ï¼Œæ‰§è¡Œä¸€æ¬¡
            if (!_hasArrivedThisFrame && _isAutoWalking) return; // ç­‰èµ°å®Œè¿™æ­¥

            StopWalking();
            _netSession.Send(C_ItemPickupPacket.Make(_autoTarget.ObjectId, _autoTarget.MapX, _autoTarget.MapY, 0));
            _myPlayer.SetAction(GameEntity.ACT_PICKUP);
            
            FinishCurrentTask(); // æ¡å®Œå°±ç»“æŸ
        }

        private void ExecuteTalkNpcTask(double delta)
        {
            int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, _autoTarget.MapX, _autoTarget.MapY);
            
            if (dist > 1)
            {
                if (!_isAutoWalking) 
                {
                    var next = GetBestNeighborPosition(_myPlayer.MapX, _myPlayer.MapY, _autoTarget.MapX, _autoTarget.MapY);
                    StartWalking(next.x, next.y);
                }
                return;
            }

            if (_isAutoWalking) StopWalking();

            TalkToNpc(_autoTarget.ObjectId);
            FinishCurrentTask();
        }

        // ====================================================================
        // [è¾…åŠ©é€»è¾‘] Profile & Prediction
        // ====================================================================
        private CombatProfile GetCombatProfile()
        {
            if (_myPlayer.IsUsingBow())
            {
                return new CombatProfile { AttackCooldown = 0.8f, CanAttackWhileMoving = true, MinAdvancePerAttack = 1, UsePredictShot = true };
            }
            if (_myPlayer.IsUsingSpear())
            {
                return new CombatProfile { AttackCooldown = 0.7f, CanAttackWhileMoving = false, MinAdvancePerAttack = 0, UsePredictShot = false };
            }
            // é»˜è®¤è¿‘æˆ˜
            return new CombatProfile { AttackCooldown = 0.6f, CanAttackWhileMoving = false, MinAdvancePerAttack = 0, UsePredictShot = false };
        }

        private (int x, int y) PredictRangedTarget(GameEntity target)
        {
            int dx = 0, dy = 0;
            // ç®€å•ä¸€æ­¥é¢„æµ‹
            switch (target.Heading)
            {
                case 0: dy = -1; break; case 1: dx = 1; dy = -1; break;
                case 2: dx = 1; break;  case 3: dx = 1; dy = 1; break;
                case 4: dy = 1; break;  case 5: dx = -1; dy = 1; break;
                case 6: dx = -1; break; case 7: dx = -1; dy = -1; break;
            }
            return (target.MapX + dx, target.MapY + dy);
        }

        // ====================================================================
        // [å…¥å£] å¤–éƒ¨è°ƒç”¨ (æ›¿æ¢åŸ StartAutoAttack)
        // ====================================================================
        public void StartAutoAttack(GameEntity target)
        {
            if (target == null) return;
            // åŠ å…¥æ”»å‡»ä»»åŠ¡ï¼Œä¼˜å…ˆçº§æ™®é€š
            EnqueueTask(new AutoTask(AutoTaskType.Attack, target));
            _isAutoAttacking = true; // ä¿æŒå…¼å®¹
        }

        public void ScanForAutoTarget()
        {
            // ä¿æŒä½ åŸæœ‰çš„ Scan é€»è¾‘ï¼Œä½†åœ¨æ‰¾åˆ°ç›®æ ‡åè°ƒç”¨ EnqueueTask
            if (_currentTask != null && _currentTask.Type == AutoTaskType.Attack && _entities.ContainsKey(_currentTask.Target.ObjectId))
            {
                return; // å·²ç»åœ¨æ‰“
            }

            // ... (å¤ç”¨ä½ åŸæ¥çš„éå†é€»è¾‘å¯»æ‰¾ bestTarget) ...
            // å‡è®¾æ‰¾åˆ°äº† bestTarget:
            // EnqueueTask(new AutoTask(AutoTaskType.Attack, bestTarget));
            // _isAutoAttacking = true;
            
            // *æ³¨æ„ï¼šä¸ºäº†ç¯‡å¹…ï¼Œæˆ‘è¿™é‡Œçœç•¥äº† Scan çš„éå†ä»£ç ï¼Œè¯·æŠŠä½ åŸæ¥çš„ scan é€»è¾‘æ¬å›æ¥ï¼Œ
            // åªæ˜¯æœ€åä¸€è¡Œæ”¹ä¸º EnqueueTask *
            
            base.ScanForAutoTarget(); // å¦‚æœä½ æ˜¯åˆ†éƒ¨ç±»ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨åˆå¹¶ä»£ç ï¼Œè¿™é‡Œå‡è®¾ä½ ä¿ç•™åŸé€»è¾‘ä¿®æ”¹
        }
    }
}
2. Client/Game/GameWorld.Movement.cs (æ‰‹è„šï¼šä¿¡å·å‘å°„å™¨)
C#

using Godot;
using System;
using Client.Network;

namespace Client.Game
{
    public partial class GameWorld
    {
        // =====================================================
        // [æ ¸å¿ƒå­—æ®µ] Movement åˆ°è¾¾ä¿¡å·ï¼ˆåªæŒç»­ä¸€å¸§ï¼‰
        // =====================================================
        private bool _hasArrivedThisFrame = false;

        private void UpdateMovementLogic(double delta)
        {
            // â˜… æ¯å¸§æ¸…ç©ºä¿¡å·
            _hasArrivedThisFrame = false;

            if (_isAutoWalking && _myPlayer != null)
            {
                _moveTimer += (float)delta;
                
                if (_moveTimer >= _moveInterval)
                {
                    _moveTimer = 0;
                    
                    // åˆ°è¾¾åˆ¤å®šäº¤ç»™ StepTowardsTarget å†…éƒ¨å¤„ç†
                    // åªéœ€è¦å‘Šè¯‰å®ƒå»å“ª
                    if (_targetMapX != 0 && _targetMapY != 0)
                    {
                        StepTowardsTarget(_targetMapX, _targetMapY);
                    }
                }
            }
        }

        private void StartWalking(int x, int y)
        {
            if (_isAutoWalking && _targetMapX == x && _targetMapY == y) return;

            // è¿™é‡Œä¸å†ç²—æš´æ¸…ç©º _attackInProgressï¼Œäº¤ç»™ Combat çŠ¶æ€æœºç®¡ç†
            
            _targetMapX = x;
            _targetMapY = y;
            _isAutoWalking = true;
            _moveTimer = 0;

            // è®¾ç½®åŠ¨ä½œ
            if (_myPlayer != null) 
            {
                _myPlayer.SetAction(_myPlayer.GetWeaponWalkAction());
            }

            StepTowardsTarget(x, y);
        }

        private void StopWalking()
        {
            if (!_isAutoWalking) return;
            
            _isAutoWalking = false;

            // æ¢å¤å¾…æœºåŠ¨ä½œ
            if (_myPlayer != null)
            {
                int walkAction = _myPlayer.GetWeaponWalkAction();
                _myPlayer.SetAction(walkAction + 3); 
            }
        }

        private void StepTowardsTarget(int tx, int ty)
        {
            if (_myPlayer == null) return;

            int cx = _myPlayer.MapX;
            int cy = _myPlayer.MapY;
            int dx = tx - cx;
            int dy = ty - cy;

            if (dx == 0 && dy == 0)
            {
                StopWalking();
                // å·²ç»é‡åˆï¼Œä¹Ÿå¯ä»¥è§†ä¸º Arrived
                _hasArrivedThisFrame = true; 
                return;
            }

            int stepX = Math.Clamp(dx, -1, 1);
            int stepY = Math.Clamp(dy, -1, 1);
            int nextX = cx + stepX;
            int nextY = cy + stepY;
            int heading = GetHeading(cx, cy, nextX, nextY);

            // å‘åŒ…
            _netSession.Send(C_MoveCharPacket.Make(nextX, nextY, heading));

            // æœ¬åœ°ç§»åŠ¨
            _myPlayer.SetMapPosition(nextX, nextY, heading);

            // â˜… æ ¸å¿ƒä¿¡å·ï¼šæ ‡è®°æœ¬å¸§å®Œæˆäº†ä¸€æ¬¡ç§»åŠ¨
            _hasArrivedThisFrame = true;
            _moveTimer = 0;
        }
    }
}
3. Client/Game/GameWorld.Input.cs (è¾“å…¥ï¼šä»»åŠ¡æŠ•é€’è€…)
C#

using Godot;
using Client.UI;
using Client.Utility;

namespace Client.Game
{
    public partial class GameWorld
    {
        // ä¿æŒåŸæœ‰çš„ _UnhandledInput æ¡†æ¶...

        private void HandleInput(InputEventMouseButton mouse)
        {
            Vector2 globalMousePos = GetGlobalMousePosition();
            bool isForceAttack = Input.IsKeyPressed(Key.Shift) || (EnableDoubleClickAttack && mouse.DoubleClick);
            GameEntity clickedEntity = GetClickedEntity(globalMousePos);

            // 1. å¼ºåˆ¶æ”»å‡» (Shift)
            if (isForceAttack)
            {
                // å¼ºåˆ¶æ”»å‡»å±äºâ€œç¬æ—¶æ“ä½œâ€ï¼Œæˆ‘ä»¬é€‰æ‹©ç›´æ¥æ‰“æ–­æ‰€æœ‰ä»»åŠ¡ï¼Œåªæ‰§è¡Œä¸€æ¬¡æ”»å‡»
                StopAutoActions(); // æ¸…ç©ºä»»åŠ¡é˜Ÿåˆ—
                StopWalking();
                
                int tid = clickedEntity?.ObjectId ?? 0;
                int tx = clickedEntity?.MapX ?? (int)(globalMousePos.X / CELL_SIZE);
                int ty = clickedEntity?.MapY ?? (int)(globalMousePos.Y / CELL_SIZE);
                
                PerformAttackOnce(tid, tx, ty);
                return;
            }

            // 2. ç‚¹å‡»å®ä½“ -> æŠ•é€’ä»»åŠ¡
            if (clickedEntity != null)
            {
                // æ€ªç‰© -> æ”»å‡»ä»»åŠ¡
                if (AlignmentHelper.IsMonster(clickedEntity.Lawful))
                {
                    _hud?.AddSystemMessage($"ç›®æ ‡é”å®š: {clickedEntity.RealName}");
                    EnqueueTask(new AutoTask(AutoTaskType.Attack, clickedEntity));
                    _isAutoAttacking = true; // æ¿€æ´» update å¾ªç¯
                }
                // NPC -> å¯¹è¯ä»»åŠ¡
                else if (AlignmentHelper.IsNpc(clickedEntity.Lawful))
                {
                    EnqueueTask(new AutoTask(AutoTaskType.TalkNpc, clickedEntity));
                    _isAutoAttacking = true;
                }
                // ç‰©å“ -> æ‹¾å–ä»»åŠ¡
                else
                {
                    // å‡è®¾éæ€ªç‰©éNPCå°±æ˜¯ç‰©å“ï¼ˆæˆ–è€…ä½ éœ€è¦ IsItem åˆ¤æ–­ï¼‰
                    EnqueueTask(new AutoTask(AutoTaskType.PickUp, clickedEntity));
                    _isAutoAttacking = true;
                }
            }
            // 3. ç‚¹å‡»ç©ºåœ° -> çº¯ç§»åŠ¨
            else
            {
                // ç§»åŠ¨ä¸èµ° TaskQueueï¼Œç›´æ¥è¦†ç›–
                StopAutoActions();
                int gx = (int)(globalMousePos.X / CELL_SIZE);
                int gy = (int)(globalMousePos.Y / CELL_SIZE);
                StartWalking(gx, gy);
            }
        }
    }
}
å®¡æ ¸æäº¤
è¿™å¥—ä»£ç å·²ç»å®ç°äº†ï¼š

Combat çŠ¶æ€æœºï¼šIdle -> Chasing -> Arrived -> Executingï¼Œé€»è¾‘ä¸¥å¯†ã€‚

Arrived ç¼“å†²ï¼šä¸“é—¨åƒæ‰ä¸€å¸§ï¼Œç¡®ä¿ Movement åœç¨³ã€‚

TaskQueueï¼šç»Ÿä¸€ç®¡ç†äº†æ”»å‡»ã€æ‹¾å–ã€å¯¹è¯ã€‚

Profile èŠ‚å¥ï¼šå¼“ç®­æ‰‹æ”¯æŒ Move-Shot-Move å¾ªç¯ï¼Œè¿‘æˆ˜æ”¯æŒ Stop-Hit-Moveã€‚

Movement ä¿¡å·ï¼š_hasArrivedThisFrame æä¾›äº†ç²¾å‡†çš„æ—¶åºæ§åˆ¶ã€‚

è¯·å®¡æ ¸å¹¶åº”ç”¨åˆ°ä½ çš„é¡¹ç›®ä¸­ã€‚è¿™åº”è¯¥æ˜¯ç›®å‰æœ€ç¨³å¥çš„ç‰ˆæœ¬ã€‚



æœ€ç»ˆç‰ˆ 1/3
Client/Game/GameWorld.Combat.cs

è¿™æ˜¯â€œå¤§è„‘â€
TaskQueue + CombatState + èŒä¸šèŠ‚å¥ å·²å®Œå…¨æ¥ç®¡æ—§é€»è¾‘



using Godot;
using System;
using System.Collections.Generic;
using Client.Network;
using Client.Data;
using Client.Utility;

namespace Client.Game
{
    public partial class GameWorld
    {
        // ============================================================
        // Task / State å®šä¹‰
        // ============================================================
        private enum AutoTaskType { Attack, PickUp, TalkNpc }
        private enum AutoTaskPriority { Normal, Forced }
        private enum AutoCombatState { Idle, Chasing, Arrived, Executing }

        private class AutoTask
        {
            public AutoTaskType Type;
            public GameEntity Target;
            public AutoTaskPriority Priority;
            public AutoTask(AutoTaskType type, GameEntity target, AutoTaskPriority priority = AutoTaskPriority.Normal)
            {
                Type = type;
                Target = target;
                Priority = priority;
            }
        }

        private struct CombatProfile
        {
            public float AttackCooldown;
            public bool CanAttackWhileMoving;
            public int MinAdvancePerAttack;
            public bool UsePredictShot;
        }

        // ============================================================
        // æ ¸å¿ƒå­—æ®µ
        // ============================================================
        private readonly LinkedList<AutoTask> _taskQueue = new();
        private AutoTask _currentTask;
        private AutoCombatState _combatState = AutoCombatState.Idle;

        private bool _attackInProgress = false;
        private float _attackCooldownTimer = 0f;
        private int _lastAttackDist = int.MaxValue;

        // ============================================================
        // Task Queue
        // ============================================================
        private void EnqueueTask(AutoTask task)
        {
            if (task.Priority == AutoTaskPriority.Forced)
            {
                _taskQueue.Clear();
                _currentTask = null;
                _combatState = AutoCombatState.Idle;
                StopWalking();
                _taskQueue.AddFirst(task);
            }
            else
            {
                _taskQueue.AddLast(task);
            }
        }

        private AutoTask GetCurrentTask()
        {
            if (_currentTask == null && _taskQueue.Count > 0)
            {
                _currentTask = _taskQueue.First.Value;
                _taskQueue.RemoveFirst();
                _combatState = AutoCombatState.Idle;
                _lastAttackDist = int.MaxValue;
            }
            return _currentTask;
        }

        private void FinishCurrentTask()
        {
            _currentTask = null;
            _combatState = AutoCombatState.Idle;
            _lastAttackDist = int.MaxValue;
        }

        public void StopAutoActions()
        {
            _taskQueue.Clear();
            _currentTask = null;
            _combatState = AutoCombatState.Idle;
            _isAutoAttacking = false;
            _isAutoPickup = false;
            _autoTarget = null;
            StopWalking();
        }

        // ============================================================
        // ä¸»å¾ªç¯
        // ============================================================
        private void UpdateCombatLogic(double delta)
        {
            var task = GetCurrentTask();
            if (task == null || _myPlayer == null) return;

            _autoTarget = task.Target;

            if (_autoTarget == null ||
                !_entities.ContainsKey(_autoTarget.ObjectId) ||
                (task.Type == AutoTaskType.Attack && _autoTarget.CurrentAction == GameEntity.ACT_DEATH))
            {
                FinishCurrentTask();
                return;
            }

            switch (task.Type)
            {
                case AutoTaskType.Attack:
                    ExecuteAttackTask(delta);
                    break;
                case AutoTaskType.PickUp:
                    ExecutePickupTask();
                    break;
                case AutoTaskType.TalkNpc:
                    ExecuteTalkNpcTask();
                    break;
            }
        }

        // ============================================================
        // Attack Task
        // ============================================================
        private void ExecuteAttackTask(double delta)
        {
            var profile = GetCombatProfile();
            int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, _autoTarget.MapX, _autoTarget.MapY);
            int range = GetAttackRange();

            switch (_combatState)
            {
                case AutoCombatState.Idle:
                case AutoCombatState.Chasing:
                    if (dist > range)
                    {
                        if (!_isAutoWalking)
                        {
                            var next = GetBestNeighborPosition(
                                _myPlayer.MapX, _myPlayer.MapY,
                                _autoTarget.MapX, _autoTarget.MapY);
                            StartWalking(next.x, next.y);
                        }
                        _combatState = AutoCombatState.Chasing;
                    }
                    else
                    {
                        _combatState = AutoCombatState.Arrived;
                    }
                    break;

                case AutoCombatState.Arrived:
                    if (!_hasArrivedThisFrame) return;
                    StopWalking();
                    _combatState = AutoCombatState.Executing;
                    break;

                case AutoCombatState.Executing:
                    HandleAttackExecution(delta, profile, dist);
                    break;
            }
        }

        private void HandleAttackExecution(double delta, CombatProfile profile, int dist)
        {
            if (_attackInProgress)
            {
                _attackCooldownTimer += (float)delta;
                if (_attackCooldownTimer < profile.AttackCooldown) return;
                _attackInProgress = false;
                _attackCooldownTimer = 0;
            }

            if (profile.CanAttackWhileMoving)
            {
                if (_isAutoWalking && !_hasArrivedThisFrame) return;
            }
            else
            {
                if (_isAutoWalking) return;
            }

            if (profile.MinAdvancePerAttack > 0 &&
                dist >= _lastAttackDist - profile.MinAdvancePerAttack &&
                _isAutoWalking)
                return;

            int tx = _autoTarget.MapX;
            int ty = _autoTarget.MapY;
            if (profile.UsePredictShot)
                (tx, ty) = PredictRangedTarget(_autoTarget);

            int heading = GetHeading(_myPlayer.MapX, _myPlayer.MapY, tx, ty);
            _myPlayer.SetHeading(heading);

            PerformAttackOnce(_autoTarget.ObjectId, tx, ty);

            _attackInProgress = true;
            _lastAttackDist = dist;

            _combatState = profile.CanAttackWhileMoving
                ? AutoCombatState.Chasing
                : AutoCombatState.Executing;
        }

        // ============================================================
        // Pickup / NPC
        // ============================================================
        private void ExecutePickupTask()
        {
            int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, _autoTarget.MapX, _autoTarget.MapY);
            if (dist > 1)
            {
                if (!_isAutoWalking)
                    StartWalking(_autoTarget.MapX, _autoTarget.MapY);
                return;
            }

            if (!_hasArrivedThisFrame) return;

            StopWalking();
            _netSession.Send(C_ItemPickupPacket.Make(
                _autoTarget.ObjectId,
                _autoTarget.MapX,
                _autoTarget.MapY, 0));
            _myPlayer.SetAction(GameEntity.ACT_PICKUP);
            FinishCurrentTask();
        }

        private void ExecuteTalkNpcTask()
        {
            int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, _autoTarget.MapX, _autoTarget.MapY);
            if (dist > 1)
            {
                if (!_isAutoWalking)
                {
                    var next = GetBestNeighborPosition(
                        _myPlayer.MapX, _myPlayer.MapY,
                        _autoTarget.MapX, _autoTarget.MapY);
                    StartWalking(next.x, next.y);
                }
                return;
            }
            if (!_hasArrivedThisFrame) return;
            StopWalking();
            TalkToNpc(_autoTarget.ObjectId);
            FinishCurrentTask();
        }

        // ============================================================
        // Profile / Prediction
        // ============================================================
        private CombatProfile GetCombatProfile()
        {
            if (_myPlayer.IsUsingBow())
                return new CombatProfile { AttackCooldown = 0.8f, CanAttackWhileMoving = true, MinAdvancePerAttack = 1, UsePredictShot = true };
            if (_myPlayer.IsUsingSpear())
                return new CombatProfile { AttackCooldown = 0.7f };
            return new CombatProfile { AttackCooldown = 0.6f };
        }

        private (int x, int y) PredictRangedTarget(GameEntity t)
        {
            return t.Heading switch
            {
                0 => (t.MapX, t.MapY - 1),
                1 => (t.MapX + 1, t.MapY - 1),
                2 => (t.MapX + 1, t.MapY),
                3 => (t.MapX + 1, t.MapY + 1),
                4 => (t.MapX, t.MapY + 1),
                5 => (t.MapX - 1, t.MapY + 1),
                6 => (t.MapX - 1, t.MapY),
                7 => (t.MapX - 1, t.MapY - 1),
                _ => (t.MapX, t.MapY)
            };
        }

        // ============================================================
        // å…¥å£ï¼ˆå…¼å®¹æ—§æ¥å£ï¼‰
        // ============================================================
        public void StartAutoAttack(GameEntity target)
        {
            if (target == null) return;
            EnqueueTask(new AutoTask(AutoTaskType.Attack, target));
            _isAutoAttacking = true;
        }
    }
}




æœ€ç»ˆç‰ˆ 2/3
Client/Game/GameWorld.Movement.cs

åªè´Ÿè´£ç§»åŠ¨ + ä¿¡å·ï¼Œä¸å†ç¢° Combat

using Godot;
using System;
using Client.Network;

namespace Client.Game
{
    public partial class GameWorld
    {
        private bool _hasArrivedThisFrame = false;

        private void UpdateMovementLogic(double delta)
        {
            _hasArrivedThisFrame = false;

            if (!_isAutoWalking || _myPlayer == null) return;

            _moveTimer += (float)delta;
            if (_moveTimer < _moveInterval) return;
            _moveTimer = 0;

            StepTowardsTarget(_targetMapX, _targetMapY);
        }

        private void StartWalking(int x, int y)
        {
            if (_isAutoWalking && _targetMapX == x && _targetMapY == y) return;

            _targetMapX = x;
            _targetMapY = y;
            _isAutoWalking = true;
            _moveTimer = 0;

            _myPlayer?.SetAction(_myPlayer.GetWeaponWalkAction());
            StepTowardsTarget(x, y);
        }

        private void StopWalking()
        {
            if (!_isAutoWalking) return;
            _isAutoWalking = false;

            if (_myPlayer != null)
            {
                int walk = _myPlayer.GetWeaponWalkAction();
                _myPlayer.SetAction(walk + 3);
            }
        }

        private void StepTowardsTarget(int tx, int ty)
        {
            int cx = _myPlayer.MapX;
            int cy = _myPlayer.MapY;
            int dx = Math.Clamp(tx - cx, -1, 1);
            int dy = Math.Clamp(ty - cy, -1, 1);

            if (dx == 0 && dy == 0)
            {
                _hasArrivedThisFrame = true;
                return;
            }

            int nx = cx + dx;
            int ny = cy + dy;
            int heading = GetHeading(cx, cy, nx, ny);

            _netSession.Send(C_MoveCharPacket.Make(nx, ny, heading));
            _myPlayer.SetMapPosition(nx, ny, heading);

            _hasArrivedThisFrame = true;
        }
    }
}

âœ… æœ€ç»ˆç‰ˆ 3/3
Client/Game/GameWorld.Input.cs

Input â†’ Task æŠ•é€’è€…ï¼Œä¸å†å†™æˆ˜æ–—é€»è¾‘

using Godot;
using Client.Utility;

namespace Client.Game
{
    public partial class GameWorld
    {
        private void HandleInput(InputEventMouseButton mouse)
        {
            Vector2 pos = GetGlobalMousePosition();
            bool force = Input.IsKeyPressed(Key.Shift);
            GameEntity e = GetClickedEntity(pos);

            if (force)
            {
                StopAutoActions();
                StopWalking();
                PerformAttackOnce(
                    e?.ObjectId ?? 0,
                    e?.MapX ?? (int)(pos.X / CELL_SIZE),
                    e?.MapY ?? (int)(pos.Y / CELL_SIZE));
                return;
            }

            if (e != null)
            {
                if (AlignmentHelper.IsMonster(e.Lawful))
                {
                    EnqueueTask(new AutoTask(AutoTaskType.Attack, e));
                    _isAutoAttacking = true;
                }
                else if (AlignmentHelper.IsNpc(e.Lawful))
                {
                    EnqueueTask(new AutoTask(AutoTaskType.TalkNpc, e));
                    _isAutoAttacking = true;
                }
                else
                {
                    EnqueueTask(new AutoTask(AutoTaskType.PickUp, e));
                    _isAutoAttacking = true;
                }
            }
            else
            {
                StopAutoActions();
                StartWalking((int)(pos.X / CELL_SIZE), (int)(pos.Y / CELL_SIZE));
            }
        }
    }
}

