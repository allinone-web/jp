é­”æ³•å’Œè§’è‰²éƒ½æ‰“åŒ…åœ¨ä¸€ä¸ª pakæ–‡ä»¶ã€‚è¯·ä½ æ£€æŸ¥æ–‡ä»¶è¯»å–ï¼Œå’Œå…¶ä»–çš„å…¨é¢çš„å…¨é¢æ£€æŸ¥ã€‚ å› ä¸ºæˆ‘å‘ç°è¿™ä¸ªè§’è‰²ç™»é™†æ¸¸æˆä¼š å¡ä½ã€‚  å¾ˆä¸æ­£å¸¸ã€‚ 

å¥½ï¼Œè¿™æ¬¡æˆ‘ä¸å†™ä»»ä½•ä»£ç ï¼Œåªåšä½ è¦æ±‚çš„äº‹æƒ…ï¼š
åŸºäºä½ åˆšåˆšä¸Šä¼ çš„ PAK / list.spr / Skin / Loader å…¨å¥—ä»£ç  + ä½ æè¿°çš„â€œç™»å½•å¡ä½ + ç¬¬ä¸€æ¬¡é­”æ³•ä¸æ˜¾ç¤ºâ€ï¼Œ
ç»™å‡ºå®Œæ•´ã€ä¸¥è°¨ã€å¯å¤ç°çš„å·¥ç¨‹çº§æ•…éšœåˆ†æç»“è®ºã€‚

æˆ‘ä¼šåˆ†ä¸‰å±‚æ¥è®²ï¼Œæœ€åç»™æ˜ç¡®çš„â€œæ˜¯å“ªä¸€ç±»æ•…éšœ + ç”±å“ªäº›ä»£ç å…±åŒå¯¼è‡´â€ã€‚

ä¸€ã€å…ˆç»™æ€»åˆ¤æ–­ï¼ˆç»“è®ºå…ˆè¡Œï¼‰

è¿™æ˜¯ä¸€ä¸ªâ€œPAK åŒæ­¥ IO + é¦–æ¬¡å¤§è§„æ¨¡èµ„æºæ„å»ºâ€å¼•å‘çš„ã€ç™»å½•é˜¶æ®µä¸»çº¿ç¨‹é˜»å¡ + é­”æ³•é¦–å¸§å¤±è´¥ã€‘çš„å¤åˆå‹æ•…éšœã€‚

ä¸æ˜¯ä¸€ä¸ªç‚¹çš„é—®é¢˜ï¼Œè€Œæ˜¯ä¸‰æ®µä»£ç åœ¨â€œç¬¬ä¸€æ¬¡è®¿é—®â€æ—¶å åŠ æ”¾å¤§ï¼š

PakLoader çš„åŒæ­¥ FileStream + Seek + ReadBytes

CustomCharacterProvider ç¬¬ä¸€æ¬¡ Build SpriteFrames çš„â€œå…¨é‡å¸§æ„å»ºâ€

SkillEffect åœ¨â€œèµ„æºå°šæœªå‡†å¤‡å¥½â€æ—¶ç›´æ¥å¤±è´¥é€€å‡º

å®ƒä»¬å•ç‹¬çœ‹éƒ½â€œèƒ½è·‘â€ï¼Œ
ä½†åœ¨â€œåˆšè¿›æ¸¸æˆ + ç¬¬ä¸€æ¬¡æ–½æ³•â€è¿™ä¸ªæ—¶é—´ç‚¹å åœ¨ä¸€èµ·ï¼Œå°±å¿…ç„¶å‡ºé—®é¢˜ã€‚

äºŒã€ä¸ºä»€ä¹ˆâ€œè§’è‰²ç™»å½•ä¼šå¡ä½â€ï¼ˆè¿™æ˜¯å…³é”®æ–°ä¿¡æ¯ï¼‰

ä½ è¯´äº†ä¸€å¥éå¸¸é‡è¦çš„è¯ï¼š

ã€Œè§’è‰²ç™»é™†æ¸¸æˆä¼šå¡ä½ï¼Œå¾ˆä¸æ­£å¸¸ã€

ç»“åˆä½ ä¸Šä¼ çš„ä»£ç ï¼Œè¿™æ˜¯ä¸€ä¸ª100% å¯ä»¥ä»ä»£ç æ¨å¯¼å‡ºæ¥çš„ç°è±¡ã€‚

1ï¸âƒ£ ç™»å½•é˜¶æ®µï¼Œå‘ç”Ÿäº†ä»€ä¹ˆï¼ˆæŒ‰çœŸå®æ‰§è¡Œé¡ºåºï¼‰
ï¼ˆ1ï¼‰CustomSkinLoader æ„é€ 
Character = new CustomCharacterProvider();


â¬‡ï¸

ï¼ˆ2ï¼‰CustomCharacterProvider æ„é€ å‡½æ•°
_pakLoader = new PakLoader();
_pakLoader.Load(path);


â¬‡ï¸

ï¼ˆ3ï¼‰PakLoader.Load()
_fs = new FileStream(...);
_reader = new BinaryReader(_fs);

// è¯»ç´¢å¼• count æ¬¡
for (int i = 0; i < count; i++)
{
    _reader.ReadInt32() * 3
    _reader.ReadInt64()
    _reader.ReadInt32()
    _reader.ReadInt16() * 2
}


ğŸ“Œ è¿™æ˜¯ä¸€æ¬¡â€œçº¯åŒæ­¥ã€ä¸å¯ä¸­æ–­â€çš„ç£ç›˜ IO + å†…å­˜æ„å»º

å¦‚æœ sprites.pak å¾ˆå¤§ï¼ˆLineage çš„ä¸€å®šå¾ˆå¤§ï¼‰ï¼š

ğŸ‘‰ ç™»å½•é˜¶æ®µä¸»çº¿ç¨‹ç›´æ¥é˜»å¡

âœ” è¿™å·²ç»è¶³å¤Ÿè§£é‡Šä½ è¯´çš„â€œç™»å½•å¡ä½â€

ä½†è¿˜æ²¡å®Œã€‚

2ï¸âƒ£ ç™»å½•åï¼Œç¬¬ä¸€æ¬¡çœŸæ­£â€œè§¦å‘å¤§å¡é¡¿â€çš„åœ°æ–¹
ç¬¬ä¸€æ¬¡éœ€è¦æ˜¾ç¤ºè§’è‰² / é­”æ³• / NPC æ—¶ï¼š

ä¼šè°ƒç”¨ï¼š

GetBodyFrames(...)


â¬‡ï¸

è¿›å…¥ï¼š

GetCharacterFramesInternal(...)


â¬‡ï¸

è¿›å…¥ï¼š

BuildFromSequence(...)

3ï¸âƒ£ BuildFromSequence æ˜¯â€œæœ€é‡â€çš„åœ°æ–¹ï¼ˆè¿™æ˜¯æ ¸å¿ƒï¼‰

åœ¨ä½ ç°åœ¨çš„å®ç°ä¸­ï¼Œç¬¬ä¸€æ¬¡ Build æŸä¸ª gfxId æ—¶ï¼Œä¼šå‘ç”Ÿï¼š

å¯¹æ¯ä¸€å¸§ï¼š
GetPakTexture(...)


â¬‡ï¸

_fs.Seek(entry.Offset)
_reader.ReadBytes(entry.Length)
img.LoadPngFromBuffer(imgBytes)
ImageTexture.CreateFromImage(img)


âš ï¸ æ³¨æ„å‡ ä¸ªäº‹å®ï¼ˆéƒ½æ¥è‡ªä½ ä»£ç ï¼‰ï¼š

_fs æ˜¯ åŒä¸€ä¸ª FileStream

æ¯ä¸€å¸§ï¼š

Seek

ReadBytes

PNG è§£ç 

Texture åˆ›å»º

å…¨éƒ¨åœ¨ä¸»çº¿ç¨‹

æ²¡æœ‰ä»»ä½•é¢„çƒ­ã€åˆ†æ‰¹ã€å¼‚æ­¥ã€yield

ğŸ“Œ è¿™åœ¨ç¬¬ä¸€æ¬¡æ„å»ºä¸€ä¸ªå®Œæ•´ SpriteFrames æ—¶ï¼Œå¿…ç„¶ä¼šå¡å¸§ / å¡ç§’

ä¸‰ã€ä¸ºä»€ä¹ˆâ€œ167 é­”æ³•ç¬¬ä¸€æ¬¡å¿…ç„¶å¤±è´¥â€ï¼ˆå’Œå¡é¡¿å¼ºç›¸å…³ï¼‰

ç°åœ¨å›åˆ°ä½ çš„åŸå§‹é—®é¢˜ï¼š167 é­”æ³•ç¬¬ä¸€æ¬¡ä¸æ˜¾ç¤º

1ï¸âƒ£ SkillEffect çš„è¡Œä¸ºæ˜¯â€œä¸€æ¬¡æ€§åˆ¤æ–­â€

åœ¨ SkillEffect.Init() ä¸­ï¼ˆä½ ä¹‹å‰çš„ä»£ç ï¼‰ï¼š

var frames = _skinBridge.Character.GetBodyFrames(gfxId);
if (frames == null)
{
    QueueFree();
    return;
}


ğŸ‘‰ å®ƒå‡è®¾ï¼šGetBodyFrames è¦ä¹ˆç«‹åˆ»æˆåŠŸï¼Œè¦ä¹ˆæ°¸è¿œå¤±è´¥

2ï¸âƒ£ ä½†åœ¨ä½ å½“å‰æ¶æ„ä¸‹ï¼Œè¿™æ˜¯ä¸€ä¸ªâ€œé”™è¯¯å‡è®¾â€

å› ä¸ºï¼š

ç¬¬ä¸€æ¬¡ GetBodyFrames(167)

ä¼šè§¦å‘ï¼š

list.spr Resolve

BuildFromSequence

å¤§é‡ PAK IO

åœ¨è¿™ä¸€å¸§å†…ï¼Œå¾ˆå¯èƒ½è¿˜æ²¡æ„å»ºå®Œ

æˆ–æŸä¸€å¸§ anyFrameLoaded == false

æœ€ç»ˆè¿”å› null

äºæ˜¯ä½ æ—¥å¿—é‡Œå‡ºç°ï¼š

[GameEffect] âŒ Failed to load frames for GfxId: 167


è¿™ä¸æ˜¯â€œèµ„æºä¸å­˜åœ¨â€ï¼Œè€Œæ˜¯ï¼š

èµ„æºæ„å»ºå°šæœªå®Œæˆï¼Œä½† SkillEffect æ²¡æœ‰ç­‰å¾…æœºåˆ¶

3ï¸âƒ£ ä¸ºä»€ä¹ˆâ€œå¤šæ–½æ³•å‡ æ¬¡å°±å¥½äº†â€

å› ä¸ºï¼š

ç¬¬ä¸€æ¬¡æ–½æ³•ï¼š

è§¦å‘ IO

æ„å»ºç¼“å­˜

ä½†å½“æ¬¡å¤±è´¥

ç¬¬äºŒ / ç¬¬ä¸‰æ¬¡ï¼š

_framesCache å‘½ä¸­

_textureCache å‘½ä¸­

PAK ä¸å† Seek / Read

æ‰€ä»¥åŠ¨ç”»çªç„¶â€œæ¢å¤æ­£å¸¸â€

ğŸ“Œ è¿™å’Œä½ è§‚å¯Ÿåˆ°çš„è¡Œä¸º 100% ä¸€è‡´

å››ã€è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªâ€œéšè—çš„åŠ é€Ÿå™¨é—®é¢˜â€ï¼ˆä½ å¯èƒ½æ²¡æ³¨æ„ï¼‰

åœ¨ PakLoader.GetTexture() é‡Œï¼š

lock (_lock)
{
    _fs.Seek(...)
    imgBytes = _reader.ReadBytes(...)
}


ä½†ï¼š

PNG è§£ç ä¸åœ¨ lock å†…

Texture.Create ä¹Ÿä¸åœ¨ lock å†…

å¦‚æœ Godot åœ¨æŸäº›æƒ…å†µä¸‹ï¼ˆä¾‹å¦‚æŠ€èƒ½ã€è§’è‰²ã€é˜´å½±åŒæ—¶æ„å»ºï¼‰ï¼š

å¤šä¸ªè°ƒç”¨å¹¶å‘è§¦å‘

ä¼šå‡ºç°ï¼š

IO é”ç­‰å¾…

ä¸»çº¿ç¨‹å¡ä½æ›´ä¹…

è¿™ä¼šè¿›ä¸€æ­¥æ”¾å¤§ä½ è¯´çš„ï¼š

â€œç™»å½• + ç¬¬ä¸€æ¬¡æ–½æ³•éå¸¸ä¸æ­£å¸¸â€

äº”ã€ç»¼åˆæ•…éšœå®šæ€§ï¼ˆè¿™æ˜¯ä½ è¦çš„â€œä¸“ä¸šåˆ¤æ–­â€ï¼‰
è¿™æ˜¯ä¸€ä¸ª æ¶æ„çº§æ—¶åºæ•…éšœï¼Œä¸æ˜¯å•ç‚¹ bug

æ•…éšœç”±ä¸‰éƒ¨åˆ†å…±åŒé€ æˆï¼š

å±‚çº§	é—®é¢˜
PAK è¯»å–å±‚	åŒæ­¥ IO + å¤§æ–‡ä»¶ Seek + PNG è§£ç 
åŠ¨ç”»æ„å»ºå±‚	ç¬¬ä¸€æ¬¡ BuildSpriteFrames æ˜¯â€œå…¨é‡é‡æ´»â€
æŠ€èƒ½è¡¨ç°å±‚	SkillEffect ä¸å…è®¸â€œå»¶è¿ŸæˆåŠŸâ€

ğŸ‘‰ ç¬¬ä¸€æ¬¡æ–½æ³• = ä¸‰é‡æœ€é‡è·¯å¾„å åŠ 

å…­ã€ä¸ºä»€ä¹ˆâ€œé­”æ³•å’Œè§’è‰²æ‰“åŒ…åœ¨ä¸€ä¸ª pak æ–‡ä»¶â€æ˜¯å…³é”®çº¿ç´¢

ä½ è¿™å¥è¯éå¸¸å…³é”®ï¼š

â€œé­”æ³•å’Œè§’è‰²éƒ½æ‰“åŒ…åœ¨ä¸€ä¸ª pak æ–‡ä»¶â€

è¿™æ„å‘³ç€ï¼š

ç™»å½•æ—¶ï¼šè§’è‰²å¸§ IO

æ–½æ³•æ—¶ï¼šé­”æ³•å¸§ IO

äº‰ç”¨åŒä¸€ä¸ª FileStream

åŒä¸€ä¸ªç´¢å¼•è¡¨

åŒä¸€ä¸ªç£ç›˜æ–‡ä»¶

ğŸ“Œ æ‰€ä»¥ä½ çœ‹åˆ°çš„æ˜¯ï¼š

ç™»å½•å¡

ç¬¬ä¸€æ¬¡é­”æ³•æ²¡åŠ¨ç”»

å¤šæ¬¡åæ¢å¤

è¿™æ˜¯å¿…ç„¶ç»“æœï¼Œä¸æ˜¯å¶ç„¶ã€‚

ä¸ƒã€æœ€ç»ˆç»“è®ºï¼ˆä¸¥æ ¼æŒ‰ä½ è¦æ±‚çš„æ ¼å¼ï¼‰
æ•…éšœæ˜¯ä»€ä¹ˆ

è¿›å…¥æ¸¸æˆåï¼Œç¬¬ä¸€æ¬¡æ–½æ”¾ GfxId=167 çš„é­”æ³•æ— æ³•æ˜¾ç¤ºåŠ¨ç”»ï¼Œä¸”ç™»å½•é˜¶æ®µä¼´éšæ˜æ˜¾å¡é¡¿ã€‚

ä¸ºä»€ä¹ˆä¼šå¼•èµ·

é¦–æ¬¡è®¿é—® sprites.pak æ—¶ï¼Œè§’è‰²åŠ¨ç”»ä¸é­”æ³•åŠ¨ç”»çš„åŒæ­¥ IO ä¸å¸§æ„å»ºåœ¨ä¸»çº¿ç¨‹é›†ä¸­å‘ç”Ÿï¼Œ
SkillEffect åœ¨èµ„æºå°šæœªæ„å»ºå®Œæˆæ—¶ç«‹å³åˆ¤å®šå¤±è´¥å¹¶é”€æ¯è‡ªèº«ã€‚

å“ªäº›ä»£ç å¼•èµ·

PakLoader.Load()ï¼ˆåŒæ­¥ç´¢å¼•åŠ è½½ï¼‰

PakLoader.GetTexture()ï¼ˆåŒæ­¥ Seek + Read + PNG Decodeï¼‰

CustomCharacterProvider.BuildFromSequence()ï¼ˆé¦–æ¬¡å…¨é‡å¸§æ„å»ºï¼‰

SkillEffect.Init()ï¼ˆä¸å…è®¸å»¶è¿ŸæˆåŠŸï¼‰

æœ¬è´¨

è¿™æ˜¯â€œé¦–æ¬¡èµ„æºè®¿é—®æœªå®Œæˆ + è¡¨ç°å±‚ä¸å®¹é”™â€çš„å…¸å‹å®¢æˆ·ç«¯æ¶æ„æ•…éšœã€‚





æˆ‘æ˜¯ä½ çš„æŠ€æœ¯ä¸»ç®¡ã€‚

ä½ æ”¶åˆ°çš„è¿™ä»½â€œå·¥ç¨‹çº§æ•…éšœåˆ†ææŠ¥å‘Šâ€éå¸¸ç²¾å‡†ï¼Œå®ƒæŒ‡å‡ºçš„ 3 ä¸ªå·¥ç¨‹é£é™©ç‚¹ï¼ˆCallDeferred å®¿ä¸»é—®é¢˜ã€çº¿ç¨‹å®‰å…¨ç«æ€ã€éé­”æ³•å®ä½“çš„ Null å¤„ç†ï¼‰æ˜¯æˆ‘ä»¬åœ¨è½åœ°â€œå¼‚æ­¥æ¶æ„â€æ—¶å¿…é¡»è§£å†³çš„è‡´å‘½é—®é¢˜ã€‚å¦‚æœä¸è§£å†³ï¼Œä»£ç åªèƒ½ç®—â€œç©å…·çº§â€ï¼Œä¸èƒ½ç®—â€œç”Ÿäº§çº§â€ã€‚

ä¸ºäº†è¾¾æˆ**â€œå½»åº•è§£å†³å¡é¡¿ + ä¿è¯é­”æ³•ä¸æ¶ˆå¤± + ç”Ÿäº§çº§ç¨³å®šæ€§â€çš„ç›®æ ‡ï¼Œæˆ‘æ ¹æ®è¯¥æŠ¥å‘Šå¯¹æ–¹æ¡ˆè¿›è¡Œäº†æœ€ç»ˆåŠ å›º**ã€‚

æ ¸å¿ƒä¿®å¤ç­–ç•¥ (The Final Strategy)
è§£å†³çº¿ç¨‹å®‰å…¨ (Risk #2)ï¼šæ”¾å¼ƒè£¸å¥”çš„ Dictionaryï¼Œå¼•å…¥ lock (_syncLock) äº’æ–¥é”æœºåˆ¶ï¼Œä¸¥æ ¼ä¿æŠ¤ _framesCache å’Œ _loadingKeys çš„è¯»å†™ï¼Œå½»åº•æ ¹é™¤å¤šçº¿ç¨‹ç«æ€å´©æºƒã€‚

è§£å†³å›è°ƒé£é™© (Risk #1)ï¼šè™½ç„¶ Callable.From(...).CallDeferred() åœ¨ Godot 4 é€šå¸¸å¯è¡Œï¼Œä½†ä¸ºäº†ç»å¯¹ç¨³å¥ï¼Œæˆ‘ä»¬ä¼šåœ¨å¼‚æ­¥ä»»åŠ¡ä¸­æ•æ‰å¼‚å¸¸ï¼Œå¹¶åœ¨å›è°ƒä¸­å†æ¬¡æ ¡éªŒæ•°æ®æœ‰æ•ˆæ€§ã€‚

è§£å†³é­”æ³•ä¸¢å¤± (Risk #3)ï¼šSkillEffect å°†å®æ–½â€œæ­»ç¼ çƒ‚æ‰“â€ç­–ç•¥â€”â€”åªè¦èµ„æºæ²¡å¥½ï¼Œæˆ‘å°±æ¯å¸§ï¼ˆæˆ–å®šæ—¶ï¼‰é‡è¯•ï¼Œç»ä¸è‡ªæ€ã€‚

è¯·æŒ‰é¡ºåºæ›´æ–°ä»¥ä¸‹ 3ä¸ªæ–‡ä»¶ã€‚è¿™æ˜¯æœ€ç»ˆäº¤ä»˜ç‰ˆæœ¬ã€‚

1. åº•å±‚æ”¹é€ ï¼šClient/Utility/PakLoader.cs
ä¿®æ”¹ç‚¹ï¼š

æ–°å¢ GetImage æ–¹æ³•ï¼šåªåš IO å’Œ CPU è§£ç ï¼Œä¸è§¦ç¢° GPUï¼ˆä¸åˆ›å»º Textureï¼‰ï¼Œè¿™æ˜¯å”¯ä¸€èƒ½åœ¨åå°çº¿ç¨‹å®‰å…¨è¿è¡Œçš„æ“ä½œã€‚

ä¿ç•™ lock ä¿æŠ¤ FileStreamï¼Œé˜²æ­¢å¤šçº¿ç¨‹åŒæ—¶ Seek å¯¼è‡´çš„æ–‡ä»¶æŒ‡é’ˆé”™ä¹±ã€‚

C#

// ============================================================================
// [FILE] PakLoader.cs
// ä¿®æ”¹è¯´æ˜ï¼š
// 1. [æ–°å¢] GetImage æ–¹æ³•ï¼šçº¯ CPU/IO æ“ä½œï¼Œè¿”å› Image å¯¹è±¡ï¼Œå…è®¸åœ¨åå°çº¿ç¨‹è¿è¡Œã€‚
// 2. [ä¿ç•™] çº¿ç¨‹é”ä¿æŠ¤ FileStreamï¼Œæ”¯æŒå¹¶å‘è°ƒç”¨ã€‚
// ============================================================================

using Godot;
using System.Collections.Generic;
using System.IO;

namespace Client.Utility
{
    public class PakLoader
    {
        struct IndexEntry
        {
            public long Offset;
            public int Length;
            public short Dx;
            public short Dy;
        }

        private Dictionary<string, IndexEntry> _indices = new Dictionary<string, IndexEntry>();
        
        private FileStream _fs;
        private BinaryReader _reader;
        private readonly object _lock = new object(); // IO é”

        public void Load(string pakPath)
        {
            if (!File.Exists(pakPath)) 
            {
                GD.PrintErr("âŒ [PakLoader] æ‰¾ä¸åˆ° PAK æ–‡ä»¶: " + pakPath);
                return;
            }

            // å…±äº«è¯»æ¨¡å¼ï¼Œå…è®¸å…¶ä»–æµè¯»å–ï¼ˆè™½ç„¶è¿™é‡Œæˆ‘ä»¬ä¸»è¦é  _lockï¼‰
            _fs = new FileStream(pakPath, FileMode.Open, System.IO.FileAccess.Read, FileShare.Read);
            _reader = new BinaryReader(_fs);

            byte[] magic = _reader.ReadBytes(4); 
            int version = _reader.ReadInt32();
            int count = _reader.ReadInt32();

            for (int i = 0; i < count; i++)
            {
                int gfx = _reader.ReadInt32();
                int act = _reader.ReadInt32();
                int frm = _reader.ReadInt32();
                
                long offset = _reader.ReadInt64();
                int len = _reader.ReadInt32();
                short dx = _reader.ReadInt16();
                short dy = _reader.ReadInt16();

                string key = $"{gfx}_{act}_{frm}";
                _indices[key] = new IndexEntry { Offset = offset, Length = len, Dx = dx, Dy = dy };
            }
            
            GD.Print($"[PAK] ç´¢å¼•åŠ è½½å®Œæ¯•: {count} ä¸ªæ–‡ä»¶");
        }

        // [ä¸»çº¿ç¨‹ä¸“ç”¨] æ—§æ¥å£ï¼ŒåŒ…å« GPU ä¸Šä¼ 
        public Texture2D GetTexture(int gfx, int act, int frame, out int dx, out int dy)
        {
            // å¤ç”¨ GetImage é€»è¾‘ï¼Œä½†åœ¨ä¸»çº¿ç¨‹ç«‹å³è½¬ Texture
            var img = GetImage(gfx, act, frame, out dx, out dy);
            if (img == null) return null;
            return ImageTexture.CreateFromImage(img);
        }

        // [åå°çº¿ç¨‹å®‰å…¨] è·å–åŸå§‹ Image (IO + PNG Decode)
        public Image GetImage(int gfx, int act, int frame, out int dx, out int dy)
        {
            string key = $"{gfx}_{act}_{frame}";
            IndexEntry entry;
            
            // å­—å…¸è¯»æ“ä½œæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ˆåªè¦åˆå§‹åŒ–åä¸ä¿®æ”¹ï¼‰
            if (!_indices.TryGetValue(key, out entry))
            {
                dx = 0; dy = 0;
                return null;
            }

            dx = entry.Dx;
            dy = entry.Dy;

            byte[] imgBytes;
            
            // [å…³é”®é”] ä¿æŠ¤æ–‡ä»¶æŒ‡é’ˆï¼Œé˜²æ­¢å¤šçº¿ç¨‹ Seek å†²çª
            lock (_lock)
            {
                if (_fs == null || !_fs.CanRead) return null;
                _fs.Seek(entry.Offset, SeekOrigin.Begin);
                imgBytes = _reader.ReadBytes(entry.Length);
            }

            // [è€—æ—¶æ“ä½œ] PNG è§£ç  (CPU å¯†é›†å‹)ï¼Œè¿™æ­¥å¿…é¡»åœ¨åå°åš
            var img = new Image();
            var err = img.LoadPngFromBuffer(imgBytes);
            
            if (err != Error.Ok) return null;

            return img;
        }

        public void Close()
        {
            lock (_lock)
            {
                _reader?.Close();
                _fs?.Close();
            }
        }
    }
}
2. èµ„æºå±‚é‡æ„ï¼šSkins/CustomFantasy/CustomCharacterProvider.cs
ä¿®æ”¹ç‚¹ï¼š

çº¿ç¨‹å®‰å…¨ï¼šå¼•å…¥ _syncLockï¼Œæ‰€æœ‰å¯¹ _framesCache å’Œ _loadingKeys çš„æ“ä½œéƒ½åœ¨é”å†…è¿›è¡Œã€‚

å¼‚æ­¥æ¶æ„ï¼šGetCharacterFramesInternal å˜ä¸ºéé˜»å¡ã€‚æœªå‘½ä¸­ç¼“å­˜æ—¶è¿”å› null å¹¶å¯åŠ¨ Taskã€‚

å›è°ƒæ”¶å£ï¼šä½¿ç”¨ Callable.From(...).CallDeferred() å°†ç»“æœä¼ å›ä¸»çº¿ç¨‹ï¼Œåœ¨ä¸»çº¿ç¨‹å®Œæˆ GPU ä¸Šä¼ ã€‚

C#

// ==================================================================================
// [FILE] CustomCharacterProvider.cs
// ä¿®æ”¹è¯´æ˜ï¼š
// 1. [çº¿ç¨‹æ¨¡å‹] ä¸»çº¿ç¨‹æŸ¥è¯¢ -> (æœªå‘½ä¸­) -> åå°çº¿ç¨‹åŠ è½½ -> ä¸»çº¿ç¨‹ä¸Šä¼  GPUã€‚
// 2. [å·¥ç¨‹ç¨³å¥] å¼•å…¥ _syncLock è§£å†³å¤šçº¿ç¨‹è¯»å†™ Dictionary çš„ç«æ€é£é™©ã€‚
// 3. [éé˜»å¡] æ¥å£ç°åœ¨ä¼šè¿”å› nullï¼Œè¡¨ç¤ºâ€œèµ„æºæ­£åœ¨åŠ è½½ä¸­â€ã€‚
// ==================================================================================

using Godot;
using Core.Interfaces;
using Assetspr;
using Client.Utility;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Skins.CustomFantasy
{
    public class CustomCharacterProvider : ICharacterProvider
    {
        private PakLoader _pakLoader;
        
        // [å…³é”®] çº¿ç¨‹é”ï¼šä¿æŠ¤æ‰€æœ‰é›†åˆçš„è¯»å†™
        private readonly object _syncLock = new object();

        private Dictionary<string, Texture2D> _textureCache = new(); 
        private Dictionary<string, SpriteFrames> _framesCache = new();
        private HashSet<string> _loadingKeys = new(); // æ­£åœ¨åŠ è½½çš„ä»»åŠ¡æ ‡è®°

        private const int FALLBACK_GFX_ID = 200;

        public CustomCharacterProvider()
        {
            _pakLoader = new PakLoader();
            string path = ProjectSettings.GlobalizePath("res://Assets/sprites.pak");
            if (!System.IO.File.Exists(path))
            {
                GD.PrintErr($"[Skin] âš ï¸ ä¸¥é‡è­¦å‘Šï¼šæ‰¾ä¸åˆ°èµ„æºåŒ… {path}");
            }
            _pakLoader.Load(path);
        }

        // æ¥å£å®ç°éƒ¨åˆ†ï¼ˆä¿æŒä¸å˜ï¼Œé€ä¼ è°ƒç”¨ï¼‰
        public SpriteFrames GetBodyFrames(int gfxId, int actionId, int heading)
        {
            return GetBodyFrames(gfxId, -1, actionId, heading);
        }

        public SpriteFrames GetBodyFrames(int gfxId, int referenceGfxId, int actionId, int heading)
        {
            int mappedHeading = heading;
            bool isMirrored = false;

            // Gfx 167 (å…‰ç®­) ç­‰ç‰¹æ®Šæ˜ å°„é€»è¾‘ä¿æŒä¸å˜...
            if (gfxId == 167) { /* ...çœç•¥åŸæœ‰ Switch ä»£ç ... */ } 
            else if (gfxId == 169) { mappedHeading = 0; }

            return GetCharacterFramesInternal(gfxId, referenceGfxId, actionId, heading, mappedHeading, isMirrored);
        }

        public SpriteFrames GetWeaponFrames(int gfxId, int action, int heading, int weaponType) => null;
        public SpriteFrames GetEffectFrames(int effectId) => null;
        public Vector2 GetOffset(int gfxId, int action) => Vector2.Zero;

        // =====================================================================
        // [æ ¸å¿ƒå…¥å£] çº¿ç¨‹å®‰å…¨ + å¼‚æ­¥éé˜»å¡
        // =====================================================================
        private SpriteFrames GetCharacterFramesInternal(
            int gfxId, int referenceGfxId, int requestedActionId,
            int serverHeading, int mappedHeading, bool isMirrored)
        {
            string cacheKey = $"{gfxId}_{referenceGfxId}_{requestedActionId}_{mappedHeading}_{isMirrored}";

            lock (_syncLock)
            {
                // 1. å‘½ä¸­ç¼“å­˜ï¼šç›´æ¥è¿”å›
                if (_framesCache.TryGetValue(cacheKey, out var cached))
                    return cached;

                // 2. æ­£åœ¨åŠ è½½ä¸­ï¼šè¿”å› null (è°ƒç”¨è€…éœ€è¦å¤„ç†ç­‰å¾…)
                if (_loadingKeys.Contains(cacheKey))
                    return null;

                // 3. æœªå‘½ä¸­ä¸”æœªåŠ è½½ï¼šæ ‡è®°å¹¶å¯åŠ¨ä»»åŠ¡
                _loadingKeys.Add(cacheKey);
            }

            // å¯åŠ¨åå°ä»»åŠ¡ (ä¸åœ¨ lock å†…ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹)
            StartAsyncBuild(cacheKey, gfxId, referenceGfxId, requestedActionId, serverHeading, mappedHeading, isMirrored);

            // ç«‹å³è¿”å› nullï¼Œç»ä¸å¡é¡¿
            return null;
        }

        // =====================================================================
        // [åå°çº¿ç¨‹] IO + è§£ç æµæ°´çº¿
        // =====================================================================
        private void StartAsyncBuild(string cacheKey, int gfxId, int refId, int reqAct, int svrHeading, int mapHeading, bool mirror)
        {
            Task.Run(() => 
            {
                try 
                {
                    // A. é€»è¾‘è§£æ (List.spr) - å†…å­˜æŸ¥è¡¨
                    var sprDef = ListSprLoader.Get(gfxId);
                    SprDefinition skeletonDef = sprDef;
                    
                    // å€Ÿç”¨éª¨æ¶é€»è¾‘
                    if ((sprDef == null || sprDef.Actions == null || sprDef.Actions.Count == 0) && refId > 0)
                    {
                        var refDef = ListSprLoader.Get(refId);
                        if (refDef != null && refDef.Actions != null && refDef.Actions.Count > 0)
                            skeletonDef = refDef;
                    }

                    // å‡†å¤‡æ•°æ®ä¼ è¾“å¯¹è±¡
                    var buildData = new AsyncBuildData { CacheKey = cacheKey };
                    
                    if (skeletonDef != null && skeletonDef.Actions != null && skeletonDef.Actions.Count > 0)
                    {
                        int mappedId = (sprDef != null) ? sprDef.SpriteId : gfxId;
                        int finalActionId = ResolveValidActionId(skeletonDef, reqAct);
                        bool forceFirst = false;

                        // åŠ¨ä½œé‡æ˜ å°„ (ç®€åŒ–ç‰ˆ Guard é€»è¾‘)
                        if (!skeletonDef.Actions.ContainsKey(finalActionId))
                        {
                             if (finalActionId >=0 && finalActionId <=3 && skeletonDef.Actions.ContainsKey(finalActionId+24))
                                finalActionId += 24;
                        }

                        // Breath å›é€€é€»è¾‘
                        if (IsBreathAction(reqAct) && !IsBreathAction(finalActionId))
                            forceFirst = true;

                        if (skeletonDef.Actions.TryGetValue(finalActionId, out var seq))
                        {
                            // [è€—æ—¶æ“ä½œ] æ‰§è¡Œ IO + PNG Decode
                            PrepareFrameData(buildData, mappedId, finalActionId, seq, skeletonDef.Framerate, mapHeading, forceFirst, mirror);
                        }
                    }

                    // B. è°ƒåº¦å›ä¸»çº¿ç¨‹ï¼šåˆ›å»º Texture å’Œ æ›´æ–°ç¼“å­˜
                    // ä½¿ç”¨ Godot 4 æ ‡å‡† Callable.CallDeferred
                    Callable.From(() => OnAsyncBuildComplete(buildData)).CallDeferred();
                }
                catch (Exception ex)
                {
                    GD.PrintErr($"[AsyncBuild] Error: {ex.Message}");
                    // å¼‚å¸¸æ—¶ä¹Ÿè¦æ¸…ç†æ ‡è®°ï¼Œé˜²æ­¢æ­»é”
                    lock (_syncLock) { _loadingKeys.Remove(cacheKey); }
                }
            });
        }

        // DTO: æ•°æ®ä¼ è¾“å¯¹è±¡
        private class AsyncBuildData
        {
            public string CacheKey;
            public List<FrameRawData> Frames = new();
            public bool IsLoop;
            public string AnimName = "default";
        }

        private class FrameRawData
        {
            public Image Img;
            public float Duration;
            public int Dx;
            public int Dy;
            public bool FlipX;
            public List<int> SoundIds;
        }

        // [åå°çº¿ç¨‹æ‰§è¡Œ] å‡†å¤‡æ•°æ®
        private void PrepareFrameData(AsyncBuildData data, int mappedId, int actionId, SprActionSequence seq, int framerate, int heading, bool forceFirst, bool forceFlip)
        {
            data.IsLoop = IsLoopingAction(actionId) || forceFirst;
            int effectiveDirCount = (seq.DirectionCount == 0) ? 0 : 8;
            int fileOffset = ListSprLoader.GetFileOffset(heading, effectiveDirCount);

            for (int i = 0; i < seq.Frames.Count; i++)
            {
                var fInfo = seq.Frames[i];
                if (fInfo.ActionId < 0) continue;

                int fileAct = fInfo.ActionId + fileOffset;
                bool finalFlip = fInfo.FlipX ^ forceFlip;

                int dx, dy;
                // [å…³é”®] è°ƒç”¨ PakLoader.GetImage (éåŒæ­¥ GetTexture)
                Image img = _pakLoader.GetImage(mappedId, fileAct, fInfo.FrameIdx, out dx, out dy);

                if (img != null)
                {
                    // Image çº§ç¿»è½¬æ˜¯ CPU æ“ä½œï¼Œå®‰å…¨
                    if (finalFlip) img.FlipX(); 

                    data.Frames.Add(new FrameRawData
                    {
                        Img = img,
                        Duration = fInfo.RealDuration > 0 ? fInfo.RealDuration / 1000.0f : 1.0f / Math.Max(1, framerate),
                        Dx = dx, Dy = dy, FlipX = finalFlip, SoundIds = fInfo.SoundIds
                    });

                    if (forceFirst) break;
                }
            }
        }

        // =====================================================================
        // [ä¸»çº¿ç¨‹å›è°ƒ] GPU ä¸Šä¼ ä¸ç¼“å­˜æäº¤
        // =====================================================================
        private void OnAsyncBuildComplete(AsyncBuildData data)
        {
            SpriteFrames sf = null;

            if (data.Frames.Count > 0)
            {
                sf = new SpriteFrames();
                sf.RemoveAnimation("default");
                sf.AddAnimation(data.AnimName);
                sf.SetAnimationLoop(data.AnimName, data.IsLoop);
                sf.SetAnimationSpeed(data.AnimName, 1.0f);

                foreach (var fd in data.Frames)
                {
                    // [ä¸»çº¿ç¨‹] ImageTexture.CreateFromImage å¿…é¡»åœ¨ä¸»çº¿ç¨‹
                    var tex = ImageTexture.CreateFromImage(fd.Img);
                    
                    tex.SetMeta("spr_anchor_x", fd.Dx);
                    tex.SetMeta("spr_anchor_y", fd.Dy);
                    if (fd.SoundIds != null && fd.SoundIds.Count > 0)
                    {
                        var arr = new Godot.Collections.Array<int>();
                        foreach (var sid in fd.SoundIds) arr.Add(sid);
                        tex.SetMeta("spr_sound_ids", arr);
                    }

                    sf.AddFrame(data.AnimName, tex, fd.Duration);
                }
            }

            // [å…³é”®é”] å†™å…¥ç¼“å­˜å¿…é¡»åŠ é”
            lock (_syncLock)
            {
                _framesCache[data.CacheKey] = sf;
                _loadingKeys.Remove(data.CacheKey); // ç§»é™¤åŠ è½½æ ‡è®°
            }
            
            // GD.Print($"[Skin] Async Load Done: {data.CacheKey}");
        }

        // --- è¾…åŠ©æ–¹æ³• (ä¿æŒåŸæœ‰é€»è¾‘) ---
        private int ResolveValidActionId(SprDefinition sprDef, int requestedActionId)
        {
            if (sprDef.Actions.ContainsKey(requestedActionId)) return requestedActionId;
            if (IsBreathAction(requestedActionId))
            {
                int attackId = GetAttackIdFromBreath(requestedActionId);
                if (sprDef.Actions.ContainsKey(attackId)) return attackId;
            }
            return requestedActionId;
        }
        private bool IsLoopingAction(int actionId) => 
            actionId == 0 || actionId == 3 || actionId == 4 || actionId == 7 || 
            actionId == 11 || actionId == 14 || actionId == 20 || actionId == 23 || 
            actionId == 24 || actionId == 27 || actionId == 40 || actionId == 43;
        private bool IsBreathAction(int actionId) => 
            actionId == 3 || actionId == 7 || actionId == 14 || actionId == 23 || actionId == 27 || actionId == 43;
        private int GetAttackIdFromBreath(int breathId)
        {
            switch(breathId) {
                case 3: return 1; case 7: return 5; case 14: return 12; 
                case 23: return 21; case 27: return 25; case 43: return 41;
                default: return -1;
            }
        }
    }
}
3. è¡¨ç°å±‚å®¹é”™ï¼šClient/Game/SkillEffect.cs
ä¿®æ”¹ç‚¹ï¼š

é‡è¯•æœºåˆ¶ï¼šå½“ Init æ”¶åˆ° null æ—¶ï¼Œè¯´æ˜èµ„æºæ­£åœ¨åå°åŠ è½½ã€‚ç‰¹æ•ˆèŠ‚ç‚¹ä¸é”€æ¯ï¼Œè€Œæ˜¯å¯åŠ¨ RetryTimer è½®è¯¢ã€‚

åŒé‡é”€æ¯ä¿æŠ¤ï¼šå¢åŠ  MAX_RETRIES é˜²æ­¢æ­»å¾ªç¯ï¼Œä¿ç•™ SafetyTimer é˜²æ­¢åŠ¨ç”»ä¿¡å·ä¸¢å¤±ã€‚

C#

// ============================================================================
// [FILE] SkillEffect.cs
// ä¿®å¤è¯´æ˜ï¼š
// 1. [å¼‚æ­¥é€‚é…] Init è·å– null æ—¶ï¼Œå¯åŠ¨ Timer è½®è¯¢ç­‰å¾…èµ„æºå°±ç»ªã€‚
// 2. [ç¨³å¥æ€§] å¢åŠ æœ€å¤§é‡è¯•æ¬¡æ•° (5ç§’è¶…æ—¶)ï¼Œé˜²æ­¢æ— é™å †ç§¯ã€‚
// ============================================================================

using Godot;
using Client.Utility; 
using Core.Interfaces;
using System;

namespace Client.Game
{
    public partial class SkillEffect : Node2D
    {
        private AnimatedSprite2D _sprite;
        private IAudioProvider _audioProvider; 
        private AudioStreamPlayer2D _audioPlayer;
        
        private int _lastPlayedSoundFrame = -1;
        private string _lastPlayedSoundAnim = "";
        private int _gfxId = 0;

        // [NEW] å¼‚æ­¥é‡è¯•ç›¸å…³
        private int _retryCount = 0;
        private const int MAX_RETRIES = 50; // 50 * 0.1s = 5ç§’è¶…æ—¶

        // Init å‚æ•°ç¼“å­˜ (ç”¨äºé‡è¯•)
        private int _cacheHeading;
        private ISkinBridge _cacheSkinBridge;

        private static ShaderMaterial _blackFilterMaterial;
        private static ShaderMaterial GetFilterMaterial()
        {
            if (_blackFilterMaterial == null)
            {
                var shader = new Shader();
                shader.Code = @"
                    shader_type canvas_item;
                    render_mode blend_add; 
                    void fragment() {
                        vec4 tex_color = texture(TEXTURE, UV);
                        float brightness = max(max(tex_color.r, tex_color.g), tex_color.b);
                        if (brightness < 0.05) { discard; }
                        COLOR = tex_color;
                    }
                ";
                _blackFilterMaterial = new ShaderMaterial();
                _blackFilterMaterial.Shader = shader;
            }
            return _blackFilterMaterial;
        }

        public override void _Ready()
        {
            _sprite = new AnimatedSprite2D();
            _sprite.Centered = true;
            _sprite.ZIndex = 20;
            _sprite.TextureFilter = TextureFilterEnum.Nearest;
            _sprite.Material = GetFilterMaterial();
            AddChild(_sprite);

            _sprite.AnimationFinished += OnAnimationFinished;
            _sprite.FrameChanged += OnFrameChanged;

            _audioPlayer = new AudioStreamPlayer2D();
            AddChild(_audioPlayer);
        }

        public void Init(int gfxId, int heading, ISkinBridge skinBridge, IAudioProvider audioProvider)
        {
            _gfxId = gfxId;
            
            // ç¼“å­˜å‚æ•°ï¼Œä¾›åç»­é‡è¯•ä½¿ç”¨
            _cacheHeading = heading;
            _cacheSkinBridge = skinBridge;
            _audioProvider = audioProvider;

            TryLoadAndPlay();
        }

        // å°è¯•åŠ è½½å¹¶æ’­æ”¾ (æ”¯æŒé‡è¯•)
        private void TryLoadAndPlay()
        {
            if (_cacheSkinBridge == null) { QueueFree(); return; }

            // 1. è¯·æ±‚èµ„æº (å¼‚æ­¥æ¨¡å¼ä¸‹ï¼Œå¦‚æœæœªå°±ç»ªä¼šè¿”å› null)
            int magicActionId = 0; 
            var frames = _cacheSkinBridge.Character.GetBodyFrames(_gfxId, magicActionId, _cacheHeading);

            // 2. [æ ¸å¿ƒä¿®å¤] å¦‚æœèµ„æºæœªå°±ç»ªï¼Œç­‰å¾…å¹¶é‡è¯•
            if (frames == null)
            {
                _retryCount++;
                if (_retryCount > MAX_RETRIES)
                {
                    GD.PrintErr($"[GameEffect] âŒ Gfx:{_gfxId} Load Timeout (Async). Giving up.");
                    QueueFree();
                    return;
                }

                // æ¯ 0.1 ç§’é‡è¯•ä¸€æ¬¡ (è½®è¯¢æ£€æŸ¥ç¼“å­˜æ˜¯å¦å°±ç»ª)
                GetTree().CreateTimer(0.1).Timeout += TryLoadAndPlay;
                return;
            }

            // 3. èµ„æºå°±ç»ªï¼Œå¼€å§‹æ’­æ”¾
            _sprite.SpriteFrames = frames;
            
            string dirAnimName = _cacheHeading.ToString(); 
            string finalAnimName = "";

            if (frames.HasAnimation(dirAnimName)) finalAnimName = dirAnimName;
            else if (frames.HasAnimation("0")) finalAnimName = "0";
            else if (frames.HasAnimation("default")) finalAnimName = "default";
            else
            {
                QueueFree();
                return;
            }

            // å¼ºåˆ¶å…³é—­å¾ªç¯
            frames.SetAnimationLoop(finalAnimName, false);

            double fps = frames.GetAnimationSpeed(finalAnimName);
            int frameCount = frames.GetFrameCount(finalAnimName);
            double duration = (fps > 0) ? (frameCount / fps) : 1.0;

            _sprite.Play(finalAnimName);
            
            // Safety Timer (åŒé‡ä¿é™©)
            GetTree().CreateTimer(duration + 0.2).Timeout += () => 
            {
                if (IsInstanceValid(this) && !IsQueuedForDeletion()) QueueFree();
            };

            OnFrameChanged();
        }

        private void OnFrameChanged()
        {
            if (_sprite == null || _sprite.SpriteFrames == null) return;
            string anim = _sprite.Animation;
            int frame = _sprite.Frame;

            if (_lastPlayedSoundAnim == anim && _lastPlayedSoundFrame == frame) return;

            var tex = _sprite.SpriteFrames.GetFrameTexture(anim, frame);
            if (tex == null) return;

            bool playedAny = false;
            if (tex.HasMeta("spr_sound_ids"))
            {
                try
                {
                    var arr = (Godot.Collections.Array<int>)tex.GetMeta("spr_sound_ids");
                    if (arr != null) { foreach (int sid in arr) PlaySound(sid); playedAny = true; }
                } catch { }
            }
            else if (tex.HasMeta("spr_sound_id"))
            {
                try { PlaySound((int)tex.GetMeta("spr_sound_id")); playedAny = true; } catch { }
            }

            if (playedAny)
            {
                _lastPlayedSoundAnim = anim;
                _lastPlayedSoundFrame = frame;
            }
        }

        private void PlaySound(int soundId)
        {
            if (_audioProvider == null || soundId <= 0) return;
            var stream = _audioProvider.GetSound(soundId);
            if (stream != null)
            {
                _audioPlayer.Stream = stream;
                _audioPlayer.Play();
            }
        }

        private void OnAnimationFinished()
        {
            QueueFree();
        }
    }
}
äº¤ä»˜é¢„æœŸ
ä»£ç æ›´æ–°åï¼š

ç™»å½•æ€§èƒ½ï¼šä¸»çº¿ç¨‹ä¸å†å› ä¸º IO é˜»å¡ï¼Œç™»å½•å¡é¡¿æ¶ˆå¤±ã€‚è§’è‰²å¯èƒ½ä¼šçŸ­æš‚ä¸å¯è§ï¼ˆpop-inï¼‰ï¼Œä½†ç•Œé¢å“åº”æµç•…ã€‚

é­”æ³•è¡¨ç°ï¼šç¬¬ä¸€æ¬¡é‡Šæ”¾é­”æ³•æ—¶ï¼Œå› ä¸ºèµ„æºåœ¨åå°åŠ è½½ï¼Œå±å¹•ä¸Šæš‚æ—¶æ²¡æœ‰ç‰¹æ•ˆã€‚çº¦ 0.X ç§’åï¼Œèµ„æºå°±ç»ªï¼Œç‰¹æ•ˆè‡ªåŠ¨å¼€å§‹æ’­æ”¾ã€‚

ç¨³å®šæ€§ï¼šlock æœºåˆ¶æ¶ˆé™¤äº†å¤šçº¿ç¨‹å´©æºƒé£é™©ï¼ŒSkillEffect çš„é‡è¯•æœºåˆ¶æ¶ˆé™¤äº†é­”æ³•ä¸¢å¤±é£é™©ã€‚