Based on the logs and your description, the root cause of "monsters not chasing" and "entity not found" is confirmed:

1.  **Position Desync on Stop**: When the player stops moving (e.g., to attack), the client logic (`StopWalking`) attempts to send a position update. However, the `SendPositionUpdateToServer` function has a hardcoded throttle (`MIN_POSITION_UPDATE_INTERVAL_MS = 640`). If the player stops less than 640ms after the last step, **the stop packet is dropped**. The server thinks the player is still moving or stuck at the previous tile, so monsters pathfind to the wrong location.
2.  **Entity Not Found**: The server sends packets for entities up to ~20 tiles away, but the client code hardcoded a `14` tile limit for caching move packets. This causes `Entity_NOT_FOUND` logs and visual glitches for distant monsters.

Here are the fixes:

### 1. Client/Game/GameWorld.Combat.cs
**Change**: Added `bool force` parameter to `SendPositionUpdateToServer` to bypass the timer check when necessary (e.g., stopping).

```csharp
using Godot;
using System;
using System.Collections.Generic;
using Client.Network;
using Client.Data;
using Client.Utility;
using System.Linq;

namespace Client.Game
{
	// GameWorld 的战斗分部类
	public partial class GameWorld
	{
		// ============================================================
		// [新架构] Task / State / Profile 定义
		// ============================================================
		private enum AutoTaskType { Attack, PickUp, TalkNpc }
		private enum AutoTaskPriority { Normal, Forced }
		private enum AutoCombatState { Idle, Chasing, Arrived, Executing }

		private class AutoTask
		{
			public AutoTaskType Type;
			public GameEntity Target;
			public AutoTaskPriority Priority;
			public int? SkillId; // 可選的技能 ID，用於快捷鍵自動攻擊（攻擊類技能或武器）
			public AutoTask(AutoTaskType type, GameEntity target, AutoTaskPriority priority = AutoTaskPriority.Normal, int? skillId = null)
			{
				Type = type;
				Target = target;
				Priority = priority;
				SkillId = skillId;
			}
		}

		private struct CombatProfile
		{
			public float AttackCooldown;      // 攻击间隔
			public bool CanAttackWhileMoving; // 是否允许移动攻击 (弓)
			public int MinAdvancePerAttack;   // 最小推进距离 (防抖)
			public bool UsePredictShot;       // 是否预判射击
		}


		// [核心修復] 嚴格對齊伺服器 CheckSpeed.java 的計時器
		private bool _attackInProgress = false;
		private float _attackCooldownTimer = 0f;
		private float _smartRetryTimer = 0f; // 【現代遊戲特性】智能重試計時器，根據剩餘冷卻時間動態調整

		// ============================================================
		// [核心字段] 任务队列与状态
		// ============================================================
		private readonly LinkedList<AutoTask> _taskQueue = new();
		private AutoTask _currentTask;
		private AutoCombatState _combatState = AutoCombatState.Idle;

		
		// 弓箭防抖记录
		private int _lastAttackDist = int.MaxValue;

		// 法師 Z 自動攻擊使用的技能 ID（預設 4 光箭）；快捷鍵 1-8 可替換
		private int _mageAutoAttackSkillId = 4;

		// 【座標同步修復】服務器確認的玩家座標（從 S_ObjectMoving 接收）
		// 攻擊時使用此座標，確保與服務器一致
		private int _serverConfirmedPlayerX = -1;
		private int _serverConfirmedPlayerY = -1;
		
		// 【關鍵修復】定期位置更新機制：每640ms發送一次位置更新包，確保服務器知道玩家最新位置
		// 這是讓怪物能夠追擊玩家的關鍵：服務器必須知道玩家的最新位置，才能正確計算怪物AI
		private float _positionUpdateTimer = 0f;
		private const float POSITION_UPDATE_INTERVAL = 0.64f; // 640ms，與遊戲移動節奏同步
		private long _lastPositionUpdateTime = 0;
		private const long MIN_POSITION_UPDATE_INTERVAL_MS = 640; // 最小發送間隔640ms
		
		// [注意] _hasArrivedThisFrame 已在 GameWorld.Movement.cs 中定义
		
		// =====================================================================
		// 【統一位置更新函數】從服務器包中更新實體位置
		// 核心原則：
		// 1. 所有實體（玩家、怪物、其他玩家）都要從服務器包中更新位置
		// 2. 如果差距 > 2格且是玩家自己，發送位置更新包給服務器
		// 3. 服務器是權威的，客戶端應該無條件信任服務器座標
		// =====================================================================
		/// <summary>
		/// 統一的位置更新函數：從服務器包中更新實體位置
		/// </summary>
		/// <param name="objectId">實體ID</param>
		/// <param name="serverX">服務器確認的X座標</param>
		/// <param name="serverY">服務器確認的Y座標</param>
		/// <param name="heading">朝向（如果為-1則不更新朝向）</param>
		/// <param name="source">來源描述（用於日誌）</param>
		private void UpdateEntityPositionFromServer(int objectId, int serverX, int serverY, int heading, string source)
		{
			if (objectId <= 0 || !_entities.TryGetValue(objectId, out var entity))
				return;
			
			int currentX = entity.MapX;
			int currentY = entity.MapY;
			int diffX = Math.Abs(serverX - currentX);
			int diffY = Math.Abs(serverY - currentY);
			int diff = Math.Max(diffX, diffY);
			
			if (diff == 0)
				return; // 位置一致，無需更新
			
			// 【簡化邏輯】如果是玩家自己，簡單處理：差距 <= 1格時更新，否則保持客戶端預測
			if (objectId == _myPlayer?.ObjectId)
			{
				// 只有當差距 <= 1格時才更新位置和服務器確認座標（服務器確認了客戶端的移動）
				if (diff <= 1)
				{
					// 服務器確認了客戶端的移動，更新位置和服務器確認座標
					_serverConfirmedPlayerX = serverX;
					_serverConfirmedPlayerY = serverY;
					int confirmedHeading = heading >= 0 ? heading : entity.Heading;
					entity.SetMapPosition(serverX, serverY, confirmedHeading);
					GD.Print($"[Pos-Sync] Server confirmed player move: ({serverX},{serverY}) client was at ({currentX},{currentY}) diff={diff}");
				}
				else
				{
					// 差距 > 1格時，保持客戶端預測，不更新位置
					// 但也不更新服務器確認座標為舊值，保持客戶端預測的座標
					GD.Print($"[Pos-Sync-Fix] Server confirmed too old (diff={diff} > 1), keeping client prediction. Server:({serverX},{serverY}) Client:({currentX},{currentY})");
				}
				return;
			}
			
			// 不是玩家自己（怪物或其他玩家），正常更新位置
			string entityType = objectId == _myPlayer?.ObjectId ? "player" : "entity";
			GD.Print($"[Pos-Sync] {source}: Updating {entityType} {objectId} position: server-confirmed ({serverX},{serverY}) client-current ({currentX},{currentY}) diff={diff}");
			
			// 更新實體位置
			int finalHeading = heading >= 0 ? heading : entity.Heading;
			entity.SetMapPosition(serverX, serverY, finalHeading);
		}
		
		// 【關鍵修復】定期位置更新：每640ms發送一次位置更新包，確保服務器知道玩家最新位置
		// 這是讓怪物能夠追擊玩家的關鍵：服務器必須知道玩家的最新位置，才能正確計算怪物AI
		// 必須在 _Process 中執行，而不是在 UpdateCombatLogic 中，確保即使沒有戰鬥任務也會執行
		private void UpdatePositionSync(double delta)
		{
			if (_myPlayer == null) return;
			
			_positionUpdateTimer += (float)delta;
			if (_positionUpdateTimer >= POSITION_UPDATE_INTERVAL)
			{
				_positionUpdateTimer = 0f;
				SendPositionUpdateToServer("PeriodicUpdate");
			}
		}
		
		// 【關鍵修復】位置更新函數：增加 force 參數
		// 當 stop walking 或座標嚴重不同步時，必須強制發送，不受最小間隔限制
		private void SendPositionUpdateToServer(string reason, bool force = false)
		{
			if (_myPlayer == null) return;
			
			long currentTime = (long)Time.GetTicksMsec();
			
			// 檢查最小發送間隔，但如果是強制發送 (force=true) 則忽略檢查
			if (!force && _lastPositionUpdateTime > 0 && (currentTime - _lastPositionUpdateTime) < MIN_POSITION_UPDATE_INTERVAL_MS)
			{
				return; // 間隔太短且非強制，跳過
			}
			
			int clientX = _myPlayer.MapX;
			int clientY = _myPlayer.MapY;
			int playerHeading = _myPlayer.Heading;
			
			// 發送位置更新包
			_netSession.Send(C_MoveCharPacket.Make(clientX, clientY, playerHeading));
			_lastPositionUpdateTime = currentTime;
			
			string forceTag = force ? "[FORCE] " : "";
			GD.Print($"[Pos-Update] {forceTag}Sending position update ({reason}): Client:({clientX},{clientY}) heading={playerHeading} ServerConfirmed:({_serverConfirmedPlayerX},{_serverConfirmedPlayerY})");
		}
		
		// 此处直接使用，无需重复声明。
		// [注意] LOGIC_RANGE_CELLS 和 VISUAL_RANGE_CELLS 已在 GameWorld.Entities.cs 中定义
		// 此处直接使用，无需重复声明。

		// 基础常量 (保留)
		private const float ATTACK_COOLDOWN = 0.6f;




		// ============================================================
		// [任务系统] 队列管理 (新核心)
		// ============================================================
		private void EnqueueTask(AutoTask task)
		{
			if (task.Priority == AutoTaskPriority.Forced)
			{
				_taskQueue.Clear();
				_currentTask = null;
				_combatState = AutoCombatState.Idle;
				StopWalking(); // 强制打断移动
				_taskQueue.AddFirst(task);
				GD.Print($"[Task] Forced Task: {task.Type}");
			}
			else
			{
				_taskQueue.AddLast(task);
			}
		}

		private AutoTask GetCurrentTask()
		{
			if (_currentTask == null && _taskQueue.Count > 0)
			{
				_currentTask = _taskQueue.First.Value;
				_taskQueue.RemoveFirst();
				// 切换任务时重置状态
				_combatState = AutoCombatState.Idle;
				_lastAttackDist = int.MaxValue;
				GD.Print($"[Task] Start: {_currentTask.Type} -> {_currentTask.Target?.RealName}");
			}
			return _currentTask;
		}

		private void FinishCurrentTask()
		{
			_currentTask = null;
			_combatState = AutoCombatState.Idle;
			_lastAttackDist = int.MaxValue;
		}

		// [合并] 停止所有自动行为 (清理队列 + 重置标志位)
		public void StopAutoActions()
		{
			_taskQueue.Clear();
			_currentTask = null;
			_combatState = AutoCombatState.Idle;
			
			// 兼容旧标志位
			_isAutoAttacking = false;
			_isAutoPickup = false;
			_autoTarget = null;
			
			StopWalking();

			GD.Print("[Combat] StopAutoActions called");
		}

		// ============================================================
	// [主循环] UpdateCombatLogic (状态机驱动)
	// [修復] 戰鬥封包頻率控制
	// ============================================================
	private void UpdateCombatLogic(double delta)
		{
			var task = GetCurrentTask();
			if (task == null || _myPlayer == null) return;

			// 任務有效性：目標存在、未死亡（依 IsDead 判定，正確的死亡判斷是 _currentRawAction == ACT_DEATH）
			var target = task.Target;
			if (target == null || !_entities.ContainsKey(target.ObjectId) ||
				(task.Type == AutoTaskType.Attack && target.IsDead))
			{
				FinishCurrentTask();
				return;
			}

			// 状态机分发（使用 task.Target，不再依賴 _autoTarget）
			switch (task.Type)
			{
				case AutoTaskType.Attack:
					ExecuteAttackTask(delta);
					break;
				case AutoTaskType.PickUp:
					ExecutePickupTask();
					break;
				case AutoTaskType.TalkNpc:
					ExecuteTalkNpcTask();
					break;
			}
		}

		// ============================================================
		// [执行单元] Attack Task (攻击任务 - 改进版)
		// ============================================================
		private void ExecuteAttackTask(double delta)
		{
			var target = _currentTask.Target;
			var profile = GetCombatProfile();
			int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, target.MapX, target.MapY);
			int range = GetAttackRange();

			switch (_combatState)
			{
				case AutoCombatState.Idle:
					// 【關鍵修復】必須走到攻擊範圍內才能攻擊，不應該在距離2格時就攻擊
					// 對於近戰（range=1），必須距離<=1格才能攻擊
					// 對於遠程（range=6），必須距離<=range才能攻擊，但為了確保服務器距離檢查通過，應該先走到距離<=range-1格
					// 服務器距離檢查使用的是玩家在服務器端的座標，如果客戶端預測與服務器不一致，距離檢查會失敗
					if (dist <= range)
					{
						// 如果距離剛好在範圍邊緣（dist == range），先走到更近的位置再攻擊
						// 這可以避免服務器座標不一致導致的距離檢查失敗
						if (dist == range && range > 1)
						{
							_combatState = AutoCombatState.Chasing;
							GD.Print($"[Combat] State: Idle → Chasing (dist={dist} == range={range}, need to get closer)");
						}
						else
						{
							_combatState = AutoCombatState.Executing;
							GD.Print($"[Combat] State: Idle → Executing (in range dist={dist} range={range}, attack immediately)");
							HandleExecutingState(delta, profile, dist, range);
						}
					}
					else
					{
						_combatState = AutoCombatState.Chasing;
						GD.Print($"[Combat] State: Idle → Chasing (dist={dist} > range={range})");
					}
					break;

				case AutoCombatState.Chasing:
					HandleChasingState(dist, range);
					break;

				case AutoCombatState.Arrived:
					HandleArrivedState(delta, profile, dist, range);
					break;

				case AutoCombatState.Executing:
					HandleExecutingState(delta, profile, dist, range);
					break;
			}
		}

		/// <summary>
		/// 追击状态处理
		/// </summary>
		private void HandleChasingState(int dist, int range)
		{
			// 【關鍵修復】必須走到攻擊範圍內才能攻擊
			// 對於近戰（range=1），必須距離<=1格
			// 對於遠程（range>1），為了確保服務器距離檢查通過，應該走到距離<=range-1格
			// 服務器距離檢查使用的是玩家在服務器端的座標，如果客戶端預測與服務器不一致，距離檢查會失敗
			int requiredDist = range > 1 ? range - 1 : range;
			
			if (dist > requiredDist)
			{
				if (!_isAutoWalking)
				{
					var t = _currentTask.Target;
					var next = GetBestNeighborPosition(_myPlayer.MapX, _myPlayer.MapY, t.MapX, t.MapY);
					StartWalking(next.x, next.y);
					GD.Print($"[Combat] Chasing: Moving to ({next.x}, {next.y}) dist={dist} requiredDist={requiredDist}");
				}
			}
			else
			{
				// 距离够了，进入到位状态（等待一帧）
				_combatState = AutoCombatState.Arrived;
				GD.Print($"[Combat] State: Chasing → Arrived (dist={dist} <= requiredDist={requiredDist})");
			}
		}

		/// <summary>
		/// 到位狀態：等本幀 StepTowardsTarget 執行完（_hasArrivedThisFrame）再轉 Executing 並攻擊，避免先送攻擊再送移動導致伺服器距離判定失敗。
		/// </summary>
		private void HandleArrivedState(double delta, CombatProfile profile, int dist, int range)
		{
			if (_isAutoWalking && !_hasArrivedThisFrame) return;

			if (_isAutoWalking)
			{
				StopWalking();
				GD.Print("[Combat] Arrived: Stopped walking");
			}

			_combatState = AutoCombatState.Executing;
			GD.Print("[Combat] State: Arrived → Executing");

			// 同一幀內立即嘗試攻擊，使用「進入 Arrived 時」的 dist/range，避免下一幀目標移動導致 dist&gt;range 而永遠打不到
			HandleExecutingState(delta, profile, dist, range);
		}

		/// <summary>
		/// 执行状态处理 - 实际执行攻击
		/// </summary>
		private void HandleExecutingState(double delta, CombatProfile profile, int dist, int range)
		{
			// 【關鍵修復】檢查目標是否還在範圍內（使用服務器確認的座標）
			// 如果目標移動了，需要重新計算距離
			if (_currentTask?.Target != null)
			{
				var target = _currentTask.Target;
				// 使用服務器確認的玩家座標和目標座標重新計算距離
				int playerX = _serverConfirmedPlayerX >= 0 ? _serverConfirmedPlayerX : _myPlayer.MapX;
				int playerY = _serverConfirmedPlayerY >= 0 ? _serverConfirmedPlayerY : _myPlayer.MapY;
				int targetX = target.MapX;
				int targetY = target.MapY;
				int actualDist = GetGridDistance(playerX, playerY, targetX, targetY);
				
				// 如果實際距離超出範圍，返回追擊狀態
				if (actualDist > range)
				{
					_combatState = AutoCombatState.Chasing;
					GD.Print($"[Combat] Target out of range (dist={actualDist} range={range}), returning to Chasing");
					return;
				}
			}
			
			// 【現代遊戲特性】智能重試機制：根據剩餘冷卻時間動態調整重試間隔
			if (_smartRetryTimer > 0)
			{
				_smartRetryTimer -= (float)delta;
				if (_smartRetryTimer > 0)
				{
					return; // 仍在智能重試間隔中，不重試
				}
				_smartRetryTimer = 0; // 重試間隔完成
			}
			
			// 1. 冷却检查（法師職業 class=3 且開啟 Z 鍵魔法攻擊時用魔法間隔，其他用攻擊間隔）
			if (_attackInProgress)
			{
				bool isMageZ = IsMageClass() && Client.Data.ClientConfig.MageZMagicAttackEnabled && !_currentTask.SkillId.HasValue;
				long intervalMs = isMageZ
					? SprDataTable.GetInterval(ActionType.Magic, _myPlayer.GfxId, GameEntity.ACT_SPELL_DIR)
					: SprDataTable.GetInterval(ActionType.Attack, _myPlayer.GfxId, _myPlayer.CurrentAction);
				float baseCooldown = intervalMs / 1000.0f;
				float currentCooldown = baseCooldown;
				
				// 【速度修復】根據 AnimationSpeed 應用加速/緩速
				// - 加速（AnimationSpeed > 1.0）：間隔縮放為 0.75
				// - 緩速（AnimationSpeed < 1.0）：間隔放大為 1.333...
				// 【診斷日誌】記錄冷卻計算過程，用於排查加速效果
				if (_myPlayer.AnimationSpeed > 1.0f) 
				{
					float beforeCooldown = currentCooldown;
					currentCooldown *= 0.75f;
					GD.Print($"[Attack-Cooldown] 加速生效 GfxId={_myPlayer.GfxId} Action={_myPlayer.CurrentAction} base={baseCooldown:F3}s before={beforeCooldown:F3}s after={currentCooldown:F3}s AnimationSpeed={_myPlayer.AnimationSpeed:F3}");
				}
				else if (_myPlayer.AnimationSpeed < 1.0f)
				{
					float beforeCooldown = currentCooldown;
					currentCooldown /= 0.75f;
					GD.Print($"[Attack-Cooldown] 緩速生效 GfxId={_myPlayer.GfxId} Action={_myPlayer.CurrentAction} base={baseCooldown:F3}s before={beforeCooldown:F3}s after={currentCooldown:F3}s AnimationSpeed={_myPlayer.AnimationSpeed:F3}");
				}

				_attackCooldownTimer += (float)delta;
				if (_attackCooldownTimer < currentCooldown)
				{
					// 【診斷日誌】記錄冷卻等待
					if ((int)(_attackCooldownTimer * 100) % 10 == 0) // 每 0.1 秒記錄一次，避免日誌過多
					{
						GD.Print($"[Attack-Cooldown] 等待冷卻 GfxId={_myPlayer.GfxId} timer={_attackCooldownTimer:F3}s / {currentCooldown:F3}s remaining={currentCooldown - _attackCooldownTimer:F3}s");
					}
					return;
				}

				// 冷却完成
				_attackInProgress = false;
				_attackCooldownTimer = 0;
				GD.Print($"[Attack-Cooldown] 冷卻完成 GfxId={_myPlayer.GfxId} Action={_myPlayer.CurrentAction}");
			}

			// 2. 距离检查（防止目标逃离）
			if (dist > range)
			{
				_combatState = AutoCombatState.Chasing;
				GD.Print($"[Combat] Target out of range (dist={dist} range={range}), returning to Chasing");
				return;
			}

			// 3. 移動攻擊：弓可邊走邊射，但須等本幀 StepTowardsTarget 後再送攻擊（_hasArrivedThisFrame），與 HandleArrivedState 同一用意
			if (profile.CanAttackWhileMoving)
			{
				if (_isAutoWalking && !_hasArrivedThisFrame)
					return;
			}
			else
			{
				if (_isAutoWalking)
				{
					GD.Print("[Combat-Diag] Executing skip: melee requires not walking (_isAutoWalking=true)");
					return;
				}
			}

			// 4. 最小推进距离 (防抖) - 防止弓在原地疯狂抖动
			if (profile.MinAdvancePerAttack > 0 && 
				dist > range && // 只有在射程外追擊時才應用推進邏輯
				dist >= _lastAttackDist - profile.MinAdvancePerAttack &&
				_lastAttackDist != int.MaxValue)
			{
				// 没有足够接近，不射
				if (profile.CanAttackWhileMoving)
				{
					// 弓继续走
					_combatState = AutoCombatState.Chasing;
				}
				// 如果當前距離沒有比上次攻擊時更近，則繼續走路，不觸發攻擊
				return;
			}

			// 5. 执行攻击
			ExecuteAttackAction(profile, dist);
		}

		/// <summary>
		/// 执行攻击动作
		// 防止「原地抽風」 (Stuttering)：
		// 對於弓箭手，如果目標正在逃跑，而你的攻擊冷卻剛好到了，如果沒有這個記錄，角色可能會每走一像素就停下來射一箭，導致看起來像是在原地不停地「抖動」而追不上人。
		// 強制推進邏輯：
		// 它確保了在自動追擊模式下，角色必須比上一次攻擊時更靠近目標至少 1 格（或指定的距離），才允許發動下一次攻擊。這保證了追擊的流暢性，讓角色表現得更像真人玩家：先跑近一點，再射擊。
		/// </summary>
		private void ExecuteAttackAction(CombatProfile profile, int dist)
		{
			// 僅用冷卻擋；不再用 IsActionBusy，避免被連續攻擊時僵硬動畫常駐導致永遠無法出刀
			if (_attackInProgress) return;

			var target = _currentTask.Target;
			int? skillId = _currentTask.SkillId; // 從任務中獲取技能 ID（快捷鍵 1-8 設置）

			// 【核心修復】如果任務指定了技能 ID（快捷鍵 1-8），使用該技能進行攻擊
			// 這樣法師可以使用物理攻擊和弓箭，而不只是魔法
			if (skillId.HasValue)
			{
				UseMagic(skillId.Value, target.ObjectId);
				_attackInProgress = true;
				_attackCooldownTimer = 0;
				_lastAttackDist = dist;
				_combatState = AutoCombatState.Chasing;
				GD.Print($"[Combat] Hotkey Skill {skillId.Value} executed. Target:{target.ObjectId} Dist:{dist}");
				return;
			}

			// 【法師 Z 鍵魔法攻擊開關】法師職業 (class=3) Z 鍵行為：
			// - 開啟時：使用魔法攻擊（預設 skill 4 光箭；可由快捷鍵 1-8 替換）
			// - 關閉時：使用普通攻擊（支持近戰、弓箭，但不支持魔法）
			if (IsMageClass() && Client.Data.ClientConfig.MageZMagicAttackEnabled)
			{
				UseMagic(_mageAutoAttackSkillId, target.ObjectId);
				_attackInProgress = true;
				_attackCooldownTimer = 0;
				_lastAttackDist = dist;
				_combatState = AutoCombatState.Chasing;
				GD.Print($"[Combat] Mage Z = Skill " + _mageAutoAttackSkillId + " executed. Target:" + target.ObjectId + " Dist:" + dist);
				return;
			}

			// 物理攻擊（非法師、法師但關閉魔法攻擊開關、或未指定技能時）
			int tx = target.MapX;
			int ty = target.MapY;
			if (profile.UsePredictShot) (tx, ty) = PredictRangedTarget(target);

			int heading = GetHeading(_myPlayer.MapX, _myPlayer.MapY, tx, ty, _myPlayer.Heading);
			_myPlayer.SetHeading(heading);

			_lastAttackDist = dist;

			// 【現代遊戲特性】PerformAttackOnce 返回 bool，表示是否成功發送攻擊包
			// 如果速度檢查失敗，PerformAttackOnce 返回 false，使用智能重試機制
			// 只有當攻擊包成功發送時，才更新狀態機
			bool attackSent = PerformAttackOnce(target.ObjectId, tx, ty);
			
			if (attackSent)
			{
				_combatState = profile.CanAttackWhileMoving ? AutoCombatState.Chasing : AutoCombatState.Executing;
				GD.Print($"[Combat] Attack executed. Target:{target.ObjectId} Dist:{dist} Type:{(profile.CanAttackWhileMoving ? "Ranged" : "Melee")}");
			}
			else
			{
				// 攻擊包被阻止（速度檢查失敗），智能重試機制已在 PerformAttackOnce 中設置
				// 這裡只記錄日誌，不更新狀態機（避免無限循環）
				GD.Print($"[Combat] Attack blocked (speed check failed). Target:{target.ObjectId} Dist:{dist} - Smart retry active (interval={_smartRetryTimer * 1000:F0}ms)");
			}
		}

		// ============================================================
		// [执行单元] Pickup & NPC Task (改进版)
		// ============================================================
		private void ExecutePickupTask()
		{
			var target = _currentTask.Target;
			// 只有 102.type(9) 才是地面物品，才可以被拾取；作為第一優先的判斷依據
			if (target == null || !IsGroundItem(target))
			{
				FinishCurrentTask();
				return;
			}
			int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, target.MapX, target.MapY);

			// 走向物品：距離 > 1 時先移動；伺服器 ItemInstance.pickup 僅在 getDistance(x,y,map,1) 時接受，故發送封包前必須 ≤1 格
			if (dist > 1)
			{
				if (!_isAutoWalking)
				{
					StartWalking(target.MapX, target.MapY);
					GD.Print($"[Pickup] Moving to item at ({target.MapX}, {target.MapY})");
				}
				return;
			}
			// 距離已 ≤1 即發送拾取，對齊伺服器 getDistance(物品座標,map,1)
			StopWalking();
			// 全部拾取：送 target.ItemCount（S_ObjectAdd 的 Exp）；伺服器要求 getCount()>=count 且 count>0，超出時 toDelete 不 insert
			int pickCount = (target.ItemCount > 0 && target.ItemCount <= int.MaxValue) ? target.ItemCount : 1;
			_netSession.Send(C_ItemPickupPacket.Make(target.ObjectId, target.MapX, target.MapY, pickCount));
			_myPlayer.SetAction(GameEntity.ACT_PICKUP);
			GD.Print($"[Pickup] Sent objectId={target.ObjectId} x={target.MapX} y={target.MapY} count={pickCount}");
			FinishCurrentTask();
		}

		private void ExecuteTalkNpcTask()
		{
			var target = _currentTask.Target;
			int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, target.MapX, target.MapY);

			if (dist > 1)
			{
				if (!_isAutoWalking)
				{
					var next = GetBestNeighborPosition(_myPlayer.MapX, _myPlayer.MapY, target.MapX, target.MapY);
					StartWalking(next.x, next.y);
					GD.Print($"[NPC] Moving to NPC at ({next.x}, {next.y})");
				}
				return;
			}
			// 距離已 ≤1 即執行，與拾取一致，不依賴 _hasArrivedThisFrame
			StopWalking();
			TalkToNpc(target.ObjectId);
			GD.Print($"[NPC] Talking to NPC: {target.ObjectId}");
			FinishCurrentTask();
		}

		// ============================================================
		// [辅助逻辑] Profile & Prediction (保留原有)
		// ============================================================
		private CombatProfile GetCombatProfile()
		{
			// 法師職業 (class=3) 默認遠程魔法攻擊
			if (IsMageClass())
			{
				return new CombatProfile { 
					AttackCooldown = 0.7f, 
					CanAttackWhileMoving = true, 
					MinAdvancePerAttack = 1, 
					UsePredictShot = true 
				};
			}

			if (_myPlayer.IsUsingBow())
				return new CombatProfile { 
					AttackCooldown = 0.8f, 
					CanAttackWhileMoving = true, 
					MinAdvancePerAttack = 1, 
					UsePredictShot = true 
				};
			if (_myPlayer.IsUsingSpear())
				return new CombatProfile { 
					AttackCooldown = 0.7f, 
					CanAttackWhileMoving = false, 
					MinAdvancePerAttack = 0, 
					UsePredictShot = false 
				};
			
			// 默认近战
			return new CombatProfile { 
				AttackCooldown = 0.6f, 
				CanAttackWhileMoving = false, 
				MinAdvancePerAttack = 0, 
				UsePredictShot = false 
			};
		}

		private (int x, int y) PredictRangedTarget(GameEntity t)
		{
			int dx = 0, dy = 0;
			switch (t.Heading)
			{
				case 0: dy = -1; break; 
				case 1: dx = 1; dy = -1; break;
				case 2: dx = 1; break;  
				case 3: dx = 1; dy = 1; break;
				case 4: dy = 1; break;  
				case 5: dx = -1; dy = 1; break;
				case 6: dx = -1; break; 
				case 7: dx = -1; dy = -1; break;
			}
			return (t.MapX + dx, t.MapY + dy);
		}

		// ========================================================================
		// [入口] 开始自动攻击 (适配旧接口)
		// ========================================================================
		/// <summary>當前攻擊任務的目標（供 Skill/UI 等使用）；無攻擊任務時為 null。</summary>
		internal GameEntity GetCurrentAttackTarget() =>
			_currentTask != null && _currentTask.Type == AutoTaskType.Attack ? _currentTask.Target : null;

		/// <summary>當前任務的目標（任意類型，供治癒等單體魔法使用）；點選其他玩家時為 PickUp 任務，需用此取得目標。</summary>
		internal GameEntity GetCurrentTaskTarget() =>
			_currentTask?.Target;

		public void StartAutoAttack(GameEntity target)
		{
			if (target == null) return;
			if (_isAutoAttacking && _currentTask?.Target == target && AlignmentHelper.IsNpc(target.Lawful))
				return;

			GD.Print($"[Combat] Enqueue Task: {target.RealName} (ID: {target.ObjectId})");
			EnqueueTask(new AutoTask(AutoTaskType.Attack, target));
			_isAutoAttacking = true;
			_isAutoPickup = false;
		}

		// ========================================================================
		// [核心] Z 鍵 = 一律重掃範圍內最佳目標並設為攻擊任務；無目標則清除攻擊任務
		// ========================================================================
		public void ScanForAutoTarget()
		{
			ScanForAutoTargetWithSkill(null);
		}

		/// <summary>
		/// 掃描範圍內最佳目標並設為攻擊任務，支持指定技能 ID（用於快捷鍵 1-8）
		/// 當 skillId 為 null 時，使用默認攻擊方式（法師用魔法，其他職業用物理攻擊）
		/// 當 skillId 不為 null 時，使用指定的技能進行攻擊
		/// </summary>
		public void ScanForAutoTargetWithSkill(int? skillId)
		{
			if (_myPlayer == null) return;
			// 已選拾取目標（地面物品）時按快捷鍵：不覆蓋任務，讓 UpdateCombatLogic 繼續執行 ExecutePickupTask（走向物品並拾取）
			if (_currentTask != null && _currentTask.Type == AutoTaskType.PickUp)
				return;

			// 遍歷尋找最佳可攻擊目標（排除死亡、超過距離）
			GameEntity bestTarget = null;
			int minScore = 9999;

			foreach (var entity in _entities.Values)
			{
				if (entity == _myPlayer) continue;
				// 排除死亡目標：正確的死亡判斷是 _currentRawAction == ACT_DEATH（收到死亡動作），而不是僅依賴 HpRatio <= 0
				if (entity.IsDead) continue;
				if (!entity.ShouldShowHealthBar()) continue;
				// 不可以刪除修改。排除己方召喚/寵物，不當成自動尋怪目標
				if (_mySummonObjectIds != null && _mySummonObjectIds.Contains(entity.ObjectId)) continue;
				// 不可以刪除修改。。排除地面物品等：僅選擇 102.type（5）/（10）有血量，才可選為攻擊目標，此規則此文字備注不可以刪除。
				int dist = GetGridDistance(_myPlayer.MapX, _myPlayer.MapY, entity.MapX, entity.MapY);
				if (dist > 15) continue;

				int score = dist * 10;
				if (AlignmentHelper.IsMonster(entity.Lawful)) score += 0;
				else if (AlignmentHelper.IsNpc(entity.Lawful)) score += 500;
				else score += 1000;

				if (score < minScore) { minScore = score; bestTarget = entity; }
			}

			if (bestTarget != null)
			{
				string skillInfo = skillId.HasValue ? $" Skill:{skillId.Value}" : "";
				GD.Print($"[Combat-Scan] Target Selected: {bestTarget.RealName} (ID:{bestTarget.ObjectId}, Action:{bestTarget.CurrentAction}, Dist:{minScore/10}{skillInfo})");
				_hud?.AddSystemMessage($"Auto Target:{bestTarget.RealName}");
				// 強制換成這次掃到的那隻：清空佇列並置入新攻擊任務（帶技能 ID）
				EnqueueTask(new AutoTask(AutoTaskType.Attack, bestTarget, AutoTaskPriority.Forced, skillId));
				_isAutoAttacking = true;
				_isAutoPickup = false;
			}
			else
			{
				// 無目標：清除攻擊任務，下次按快捷鍵不會被「已有任務」擋住
				if (_currentTask != null && _currentTask.Type == AutoTaskType.Attack)
					FinishCurrentTask();
			}
		}

		// ========================================================================
		// [原有核心] 执行单次攻击 (被 HandleAttackExecution 调用)
		// ========================================================================
		/// <summary>
		/// 執行單次攻擊（增強版：使用現代遊戲最佳實踐）
		/// </summary>
		/// <param name="targetId">目標ID</param>
		/// <param name="targetX">目標X座標</param>
		/// <param name="targetY">目標Y座標</param>
		/// <returns>true 表示成功發送攻擊包，false 表示被阻止（速度檢查失敗等）</returns>
		public bool PerformAttackOnce(int targetId, int targetX, int targetY)
		{
			if (_myPlayer == null) return false;
			int actionId = IsUsingBow() ? GameEntity.ACT_ATTACK_BOW : GameEntity.ACT_ATTACK;
			
			// 【現代遊戲特性】使用增強版速度檢查，獲取剩餘冷卻時間
			// 如果速度檢查失敗，使用智能重試機制，根據剩餘時間動態調整重試間隔
			if (!EnhancedSpeedManager.CanPerformAction(ActionType.Attack, _myPlayer.GfxId, actionId, out float remainingMs))
			{
				// 【智能重試】根據剩餘冷卻時間動態調整重試間隔
				float retryInterval = EnhancedSpeedManager.GetSmartRetryInterval(remainingMs);
				_smartRetryTimer = retryInterval;
				
				// 【診斷日誌】僅在剩餘時間較長時記錄，避免日誌過多
				if (remainingMs > 50)
				{
					GD.Print($"[SpeedManager] Attack on cooldown. GfxId={_myPlayer.GfxId} ActionId={actionId} remaining={remainingMs:F0}ms retryIn={retryInterval * 1000:F0}ms");
				}
				return false; // 直接返回 false，不設置 _attackInProgress，不播放動畫
			}
			if (targetId == 0 && _isAutoAttacking) return false;

			_attackInProgress = true;
			_attackCooldownTimer = 0;

			// 【座標同步修復】使用最新的玩家座標
			// 由於客戶端預測移動時會立即更新 _serverConfirmedPlayerX/Y，所以它始終是最新的
			bool isMoving = _isAutoWalking;
			int clientX = _myPlayer.MapX;
			int clientY = _myPlayer.MapY;
			// 使用 _serverConfirmedPlayerX/Y（客戶端預測移動時已更新為最新值），如果尚未初始化則使用客戶端座標
			int playerX = _serverConfirmedPlayerX >= 0 ? _serverConfirmedPlayerX : clientX;
			int playerY = _serverConfirmedPlayerY >= 0 ? _serverConfirmedPlayerY : clientY;
			
			int distance = GetGridDistance(playerX, playerY, targetX, targetY);
			
			// 【座標同步診斷日誌】記錄攻擊時的完整座標信息，用於排查座標不同步問題
			GD.Print($"[Combat-Diag] Attack targetId={targetId} targetGrid=({targetX},{targetY}) playerPos=({playerX},{playerY}) clientPredicted=({clientX},{clientY}) distance={distance} isMoving={isMoving}");

			// 【朝向同步修復】攻擊前調整朝向，使用服務器確認的座標計算朝向，確保精準對應
			// 使用 GameWorld.GetHeading 確保與移動邏輯一致，避免雙方同時調整朝向的衝突
			// 注意：PlayAttackAnimation 內部也會調整朝向，但會使用客戶端座標
			// 我們在這裡先使用服務器確認的座標調整朝向，確保精準對應
			if (targetX != 0 && targetY != 0 && (targetX != playerX || targetY != playerY))
			{
				int attackHeading = GetHeading(playerX, playerY, targetX, targetY, _myPlayer.Heading);
				_myPlayer.SetHeading(attackHeading);
				// 注意：SetHeading 內部會檢查是否重複，所以即使 PlayAttackAnimation 再次調用也不會重複調整
			}

			if (IsUsingBow())
			{
				SendAttackBowPacket(targetId, targetX, targetY, playerX, playerY, isMoving);
				_myPlayer.SetAction(GameEntity.ACT_ATTACK_BOW);
			}
			else
			{
				SendAttackPacket(targetId, targetX, targetY, playerX, playerY, isMoving);
				// 【朝向同步修復】PlayAttackAnimation 內部也會調整朝向，但 SetHeading 會跳過重複調整
				// 這樣可以確保使用服務器確認的座標計算朝向，而不是客戶端預測的座標
				_myPlayer.PlayAttackAnimation(targetX, targetY);
			}
			
			// 成功發送攻擊包，返回 true
			return true;
		}
		

		// ========================================================================
		// [原有逻辑] 网络发包、距离计算、武器判断 (完整保留)
		// ========================================================================

		private void SendAttackPacket(int tid, int x, int y, int playerX, int playerY, bool isMoving)
		{
			var w = new PacketWriter();
			w.WriteByte(23);
			w.WriteInt(tid);
			w.WriteUShort(x);  // 目標座標（協議規定）
			w.WriteUShort(y);  // 目標座標（協議規定）
			_netSession.Send(w.GetBytes());
			// 【座標同步診斷】記錄發送攻擊包的完整信息，用於與服務器端日誌對比
			GD.Print($"[Combat-Packet] Sent Attack(23) -> TargetID:{tid} TargetGrid:({x},{y}) PlayerGrid:({playerX},{playerY}) IsMoving:{isMoving}");
		}

		private void SendAttackBowPacket(int tid, int x, int y, int playerX, int playerY, bool isMoving)
		{
			var w = new PacketWriter();
			w.WriteByte(24);
			w.WriteInt(tid);
			w.WriteUShort(x);  // 目標座標（協議規定）
			w.WriteUShort(y);  // 目標座標（協議規定）
			_netSession.Send(w.GetBytes());
			// 【座標同步診斷】記錄發送攻擊包的完整信息，用於與服務器端日誌對比
			GD.Print($"[Combat-Packet] Sent AttackBow(24) -> TargetID:{tid} TargetGrid:({x},{y}) PlayerGrid:({playerX},{playerY}) IsMoving:{isMoving}");
		}

		private (int x, int y) GetBestNeighborPosition(int myX, int myY, int targetX, int targetY)
		{
			if (GetGridDistance(myX, myY, targetX, targetY) <= 1)
				return (myX, myY);

			int bestX = targetX;
			int bestY = targetY;
			double minMetric = 99999.0;
			bool found = false;

			for (int dx = -1; dx <= 1; dx++)
			{
				for (int dy = -1; dy <= 1; dy++)
				{
					if (dx == 0 && dy == 0) continue;

					int checkX = targetX + dx;
					int checkY = targetY + dy;

					double metric = Math.Sqrt(Math.Pow(checkX - myX, 2) + Math.Pow(checkY - myY, 2));

					if (metric < minMetric)
					{
						minMetric = metric;
						bestX = checkX;
						bestY = checkY;
						found = true;
					}
				}
			}

			return found ? (bestX, bestY) : (targetX, targetY);
		}

		/// <summary>
		/// 【關鍵重構】統一距離計算方法：使用 Euclidean distance 對齊服務器邏輯
		/// 服務器使用：Math.sqrt(dx*dx + dy*dy)，然後轉換為 int
		/// 這確保客戶端和服務器的距離檢查一致，避免攻擊失敗
		/// </summary>
		private int GetGridDistance(int x1, int y1, int x2, int y2)
		{
			long dx = x2 - x1;
			long dy = y2 - y1;
			double distance = Math.Sqrt(dx * dx + dy * dy);
			return (int)distance; // 對齊服務器邏輯：Math.sqrt 後轉換為 int
		}
		
		/// <summary>
		/// 【新增】Chebyshev distance（用於移動路徑計算，不用于攻擊距離檢查）
		/// 僅用於移動邏輯，不用于攻擊距離判斷
		/// </summary>
		private int GetChebyshevDistance(int x1, int y1, int x2, int y2)
		{
			return Math.Max(Math.Abs(x1 - x2), Math.Abs(y1 - y2));
		}

		/// <summary>
		/// 攻擊距離（格數）唯一來源：list.spr 102.type(8) 或 102.type(9) 括號內數字；無則依武器/角色 fallback。禁止其他處再寫死攻擊距離。
		/// </summary>
		private int GetAttackRange()
		{
			var def = ListSprLoader.Get(_myPlayer.GfxId);
			if (def != null && (def.Type == 8 || def.Type == 9))
				return def.Type;
			return GetAttackRangeFallback();
		}

		private int GetAttackRangeFallback()
		{
			if (IsMageClass()) return 6;
			if (IsUsingBow()) return 6;
			if (IsUsingSpear()) return 2;
			return 1;
		}

		/// <summary>
		/// 根據 actionId 判斷怪物的攻擊範圍（對齊服務器 Areaatk）
		/// 服務器使用 Areaatk 判斷攻擊範圍（近戰=2，遠程=12）
		/// 正確的 actionId 定義：
		/// - 18.spell direction, 19.spell no direction: 魔法攻擊遠程（範圍由 skill_list.csv 的 range 決定，通常為 6-12）
		/// - 21.attack bow: 弓箭攻擊遠程（Areaatk=12）
		/// - 1.attack, 5.attack sword, 12.attack Axe, 30.alt attack: 近戰（Areaatk=2）
		/// - 24.walk Spear, 41.attack staff: 近戰遠距離，長矛類（Areaatk=2，但攻擊距離可能更遠）
		/// </summary>
		private int GetMonsterAttackRange(int actionId)
		{
			// 根據 actionId 判斷攻擊類型
			// 魔法攻擊：18, 19（範圍由 skill_list.csv 決定，這裡使用默認值 12）
			if (actionId == 18 || actionId == 19)
			{
				return 12; // 魔法攻擊遠程（實際範圍由 skill_list.csv 決定，這裡使用默認值）
			}
			// 弓箭攻擊：21
			else if (actionId == 21)
			{
				return 12; // 弓箭攻擊遠程
			}
			// 長矛類：24, 41（近戰遠距離，但攻擊範圍仍為 2）
			else if (actionId == 24 || actionId == 41)
			{
				return 2; // 長矛類，雖然是遠距離，但攻擊範圍仍為 2
			}
			// 近戰攻擊：1, 5, 12, 30
			// 【核心修復】近戰攻擊的有效距離是1格（服務器 Attack() 檢查 getDistance(x, y, target.getMap(), 2) 但這是傷害檢查）
			// 實際攻擊動畫應該只在距離<=1時播放，因為只有1格內才能有效攻擊
			else if (actionId == 1 || actionId == 5 || actionId == 12 || actionId == 30)
			{
				return 1; // 近戰攻擊有效距離是1格
			}
			// 默認：近戰（有效距離1格）
			else
			{
				return 1; // 默認近戰攻擊有效距離是1格
			}
		}

		private bool IsUsingBow() 
		{ 
			return _myPlayer != null && _myPlayer.IsUsingBow();
		} 
		
		private bool IsUsingSpear() 
		{ 
			return _myPlayer != null && _myPlayer.IsUsingSpear();
		}

		/// <summary>
		/// 法師職業判定：依職業 class=3（對齊 C_CreateCharPacket.ClassType.Wizard）。若 MyCharInfo.Type 尚未同步（如 DevMode 先進世界再收角色列表），從 CharacterList 依 CurrentCharName 補齊。
		/// </summary>
		private bool IsMageClass()
		{
			var boot = GetNodeOrNull<Client.Boot>("/root/Boot");
			if (boot?.MyCharInfo == null) return false;
			if (boot.MyCharInfo.Type == 0 && boot.CharacterList != null)
			{
				foreach (var c in boot.CharacterList)
				{
					if (c.Name == boot.CurrentCharName) { boot.MyCharInfo.Type = c.Type; break; }
				}
			}
			return boot.MyCharInfo.Type == 3;
		}

		/// <summary>法師 Z 自動攻擊時使用的技能 ID；快捷鍵 1-8 設為技能時會呼叫此方法替換。</summary>
		public void SetMageAutoAttackSkill(int skillId)
		{
			_mageAutoAttackSkillId = skillId;
		}

		// [注意] GetHeading 已在 Movement.cs 中定义，此处直接调用，不需重写。

		// ========================================================================
		// [表现回调] 打击感与特效 (完整保留)
		// ========================================================================
		private void SubscribeEntityEvents(GameEntity entity)
		{
			entity.OnAttackKeyFrameHit += HandleEntityAttackHit;
		}

		private void UnsubscribeEntityEvents(GameEntity entity)
		{
			entity.OnAttackKeyFrameHit -= HandleEntityAttackHit;
		}

		private void HandleEntityAttackHit(int targetId, int damage)
		{
			bool inWorld = _entities.TryGetValue(targetId, out var target);
			GD.Print($"[HitChain] HandleEntityAttackHit target={targetId} damage={damage} inWorld={inWorld}");
			if (inWorld && target != null)
			{
				target.OnDamagedVisual(damage);
				// 怪物血條：收到傷害封包時依傷害估算新比例並更新（104 若後到會覆寫為正確值）
				if (target != _myPlayer && damage > 0)
				{
					int newRatio = Math.Max(0, target.HpRatio - damage);
					target.SetHpRatio(newRatio);
				}
				// 已死亡目標不再播放受擊僵硬，避免封包順序導致「先收到 ObjectAction(8) 再收到命中」時死亡動畫被覆蓋
				if (damage > 0 && !target.IsDead)
				{
					target.SetAction(GameEntity.ACT_DAMAGE);
					target.OnDamageStutter();
					GD.Print($"[HitChain] Target {targetId} SetAction(DAMAGE)+Stutter done");
				}
				else if (damage <= 0)
					GD.Print($"[HitChain] Target {targetId} MISS (damage<=0), only OnDamagedVisual");
				else
					GD.Print($"[HitChain] Target {targetId} already dead (IsDead=true), skip DAMAGE animation");
			}
			else
				GD.PrintErr($"[HitChain] HandleEntityAttackHit target {targetId} NOT in _entities");
		}

		// ========================================================================
		// [事件回调] 服务器交互
		// ========================================================================

		private void OnObjectMoved(int objectId, int x, int y, int heading)
		{
			// 【座標同步修復】處理所有實體的移動包（玩家、怪物、其他玩家）
			// 使用統一函數更新位置，如果差距 > 2格且是玩家自己，會發送位置更新包給服務器
			
			// 【關鍵修復】記錄移動包確認時間，用於診斷丟包問題（僅玩家自己）
			if (objectId == _myPlayer?.ObjectId)
			{
				long currentTime = (long)Time.GetTicksMsec();
				if (_lastMovePacketTime > 0)
				{
					long timeSinceLastPacket = currentTime - _lastMovePacketTime;
					
					// 【關鍵驗證】檢查服務器確認移動包的時間間隔
					// 如果間隔 > 640ms * 2，說明可能丟包或延遲
					if (timeSinceLastPacket > 1280)
					{
						GD.PrintErr($"[Move-Confirm-Error] Server confirmed player move interval too long! ({x},{y}) client predicted: ({_myPlayer.MapX},{_myPlayer.MapY}) timeSinceLastPacket={timeSinceLastPacket}ms (可能丟包，服務器可能不知道玩家最新座標)");
					}
					else
					{
						GD.Print($"[Move-Confirm] Server confirmed player move: ({x},{y}) client predicted: ({_myPlayer.MapX},{_myPlayer.MapY}) timeSinceLastPacket={timeSinceLastPacket}ms");
					}
				}
				else
				{
					GD.Print($"[Move-Confirm] Server confirmed player move: ({x},{y}) client predicted: ({_myPlayer.MapX},{_myPlayer.MapY}) (first confirmation)");
				}
				_lastMovePacketTime = currentTime;
			}
			
			
			// 【統一位置更新】使用統一函數更新所有實體位置
			UpdateEntityPositionFromServer(objectId, x, y, heading, "S_ObjectMoving");
			
			// 【診斷】記錄移動包信息（位置已經在 UpdateEntityPositionFromServer 中更新）
			if (_entities.TryGetValue(objectId, out var updatedEntity))
			{
				// 記錄移動包信息
				GD.Print($"[Move-Packet] Received S_ObjectMoving objectId={objectId} nextPos=({x},{y}) heading={heading} currentPos=({updatedEntity.MapX},{updatedEntity.MapY})");
				
				// 【診斷日誌】如果是怪物移動包，記錄詳細信息
				if (objectId != _myPlayer?.ObjectId)
				{
					int distanceToPlayer = GetEntityDistance(x, y);
					
					// 【關鍵診斷】記錄怪物收到移動包的時間戳
					long currentTime = (long)Time.GetTicksMsec();
					long timeSinceLastMove = 0;
					if (_lastMonsterMoveTime.ContainsKey(objectId) && _lastMonsterMoveTime[objectId] > 0)
					{
						timeSinceLastMove = currentTime - _lastMonsterMoveTime[objectId];
					}
					_lastMonsterMoveTime[objectId] = currentTime;
					
					GD.Print($"[Move-Diag] Monster {objectId} received move packet:");
					GD.Print($"  From: ({updatedEntity.MapX},{updatedEntity.MapY}) To: ({x},{y})");
					GD.Print($"  Distance to player: {distanceToPlayer} cells");
					GD.Print($"  Player at: ({_myPlayer?.MapX},{_myPlayer?.MapY})");
					GD.Print($"  Time since last move: {timeSinceLastMove}ms (0=first move packet)");
				}
			}
			else
			{
				// 【診斷日誌】記錄找不到實體的情況，用於排查傷害為0的問題
				// 【核心修復】對齊服務器邏輯：服務器使用 Euclidean distance 和 14格過濾
				// 服務器代碼：L1Object.updateObject() 使用 getDistance(o, 14) 判斷是否發送 S_ObjectMoving
				// 客戶端必須使用相同的距離計算方法（Euclidean distance）和相同的過濾範圍（14格）
				int distanceToPlayer = 0;
				if (_myPlayer != null)
				{
					long dx = x - _myPlayer.MapX;
					long dy = y - _myPlayer.MapY;
					distanceToPlayer = (int)Math.Sqrt(dx * dx + dy * dy); // Euclidean distance（對齊服務器邏輯）
				}
				
				// 【關鍵修復】如果距離玩家較近（<=14格），緩存移動包，等待實體創建後應用
				// 這解決了時序問題：服務器可能先發送移動包，然後才發送創建包
				// 使用 14格 對齊服務器邏輯（服務器使用 getDistance(o, 14)）
				if (distanceToPlayer <= 14)
				{
					// 【關鍵修復】更新緩存的移動包（如果已存在，使用最新的）
					_pendingMovePackets[objectId] = (x, y, heading);
					GD.Print($"[Move-Cache] ObjId={objectId} entity not found but within range (dist={distanceToPlayer} <= 14), caching move packet: ({x},{y}) heading={heading}");
				}
				else
				{
					GD.Print($"[Pos-Sync-Warn] ObjID:{objectId} Server_Grid:({x},{y}) heading={heading} Entity_NOT_FOUND distanceToPlayer={distanceToPlayer} (超出14格範圍，不緩存移動包)");
				}
			}
		}

		/// <summary>Op35 單體魔法傷害：依封包 magicFlag==6 判定，與 actionId 無關；變身時 action 可能非 17/18/19。</summary>
		private void OnObjectMagicDamage35(int attackerId, int targetId, int damage)
		{
			// 【核心修復】檢查攻擊者是否存在且未死亡
			// 如果攻擊者不存在或已死亡，跳過傷害結算
			// 正確的死亡判斷是 _currentRawAction == ACT_DEATH（收到死亡動作），而不是僅依賴 HpRatio <= 0
			if (attackerId > 0 && _entities.TryGetValue(attackerId, out var attacker))
			{
				// 檢查攻擊者是否已死亡
				if (attacker.IsDead)
				{
					GD.Print($"[Combat-Fix] OnObjectMagicDamage35: Attacker {attackerId} is dead (IsDead=true), skipping damage");
					return; // 完全跳過，不結算傷害
				}
			}
			else if (attackerId > 0)
			{
				// 攻擊者實體不存在，跳過傷害結算
				GD.Print($"[Combat-Fix] OnObjectMagicDamage35: Attacker {attackerId} entity not found, skipping damage");
				return; // 完全跳過，不結算傷害
			}
			
			// 只有當攻擊者存在且未死亡時，才結算傷害
			if (targetId > 0) HandleEntityAttackHit(targetId, damage);
		}

		private void OnObjectAttacked(int attackerId, int targetId, int actionId, int damage)
		{
			GD.Print($"[Combat-Packet] Received Op35 attacker={attackerId} target={targetId} action={actionId} damage={damage}");
			if (attackerId == _myPlayer.ObjectId)
			{
				_attackInProgress = false;
			}

			// 傷害結算：Op35 單體魔法已由 ObjectMagicDamage35 結算，此處僅做動畫 + 物理 PrepareAttack
			bool isOp35Magic = PacketHandlerRef != null && PacketHandlerRef.LastOp35WasMagic;
			
			// 【核心修復】檢查攻擊者是否存在且未死亡
			// 如果攻擊者不存在或已死亡，完全跳過處理（包括傷害結算）
			// 正確的死亡判斷是 _currentRawAction == ACT_DEATH（收到死亡動作），而不是僅依賴 HpRatio <= 0
			if (_entities.TryGetValue(attackerId, out var attacker))
			{
				// 檢查攻擊者是否已死亡
				if (attacker.IsDead)
				{
					GD.Print($"[Combat-Fix] Attacker {attackerId} is dead (IsDead=true), skipping attack and damage");
					return; // 完全跳過，不結算傷害
				}
			}
			else if (attackerId > 0)
			{
				// 攻擊者實體不存在，完全跳過處理（包括傷害結算）
				GD.Print($"[Combat-Fix] Attacker {attackerId} entity not found, skipping attack and damage");
				return; // 完全跳過，不結算傷害
			}
			
			// 【核心修復】只有當攻擊者存在且未死亡時，才處理攻擊動畫和傷害結算
			if (attacker != null)
			{
				attacker.SetAction(actionId);
				
				// 【修復】如果是怪物攻擊玩家，調整朝向面向目標（使用最新的玩家座標）
				// 由於客戶端預測移動時會立即更新 _serverConfirmedPlayerX/Y，所以它始終是最新的
				if (targetId > 0 && targetId == _myPlayer?.ObjectId)
				{
					// 目標是玩家自己，使用最新的座標（_serverConfirmedPlayerX/Y 在客戶端預測移動時已更新為最新值）
					int targetX = _serverConfirmedPlayerX >= 0 ? _serverConfirmedPlayerX : _myPlayer.MapX;
					int targetY = _serverConfirmedPlayerY >= 0 ? _serverConfirmedPlayerY : _myPlayer.MapY;
					
					// 調整攻擊者朝向
					int newHeading = GetHeading(attacker.MapX, attacker.MapY, targetX, targetY, attacker.Heading);
					attacker.SetHeading(newHeading);
					
					// 【關鍵修復】根據攻擊類型動態判斷攻擊範圍（對齊服務器 Areaatk）
					// 服務器使用 Areaatk 判斷攻擊範圍（近戰=2，遠程=12）
					// 客戶端沒有 Areaatk 信息，但可以根據 actionId 判斷攻擊類型
					// 只有當 damage > 0 且 dist <= attackRange 時，才播放攻擊動畫
					int dist = GetGridDistance(attacker.MapX, attacker.MapY, targetX, targetY);
					int attackRange = GetMonsterAttackRange(actionId); // 根據 actionId 判斷攻擊範圍
					bool shouldPlayAttack = damage > 0 && dist <= attackRange;
					
					// 【關鍵驗證】記錄怪物攻擊時的座標信息，用於診斷丟包問題
					// 如果怪物攻擊時使用的玩家座標與客戶端預測座標差距 > 2格，說明可能丟包
					int playerX = _myPlayer.MapX;
					int playerY = _myPlayer.MapY;
					int coordDiff = Math.Max(Math.Abs(targetX - playerX), Math.Abs(targetY - playerY));
					
					// 【診斷日誌】記錄怪物攻擊時的詳細信息，用於分析故障
					// 1. 怪物位置
					// 2. 服務器認為的玩家位置（targetX, targetY）
					// 3. 客戶端預測的玩家位置（playerX, playerY）
					// 4. 服務器確認的玩家位置（_serverConfirmedPlayerX, _serverConfirmedPlayerY）
					// 5. 距離和攻擊範圍
					// 6. 怪物是否在移動（檢查是否有 ACT_WALK 動作）
					// 7. 攻擊時間戳，用於追蹤攻擊間隔
					int monsterX = attacker.MapX;
					int monsterY = attacker.MapY;
					int monsterCurrentAction = attacker.CurrentAction;
					int monsterVisualBaseAction = attacker.VisualBaseAction;
					bool isMonsterWalking = monsterCurrentAction == (GameEntity.ACT_WALK + monsterVisualBaseAction);
					
					// 【關鍵診斷】記錄攻擊時間戳，用於追蹤攻擊間隔和移動包缺失
					long currentTime = (long)Time.GetTicksMsec();
					if (!_lastMonsterAttackTime.ContainsKey(attackerId))
					{
						_lastMonsterAttackTime[attackerId] = 0;
					}
					long timeSinceLastAttack = _lastMonsterAttackTime[attackerId] > 0 ? currentTime - _lastMonsterAttackTime[attackerId] : 0;
					_lastMonsterAttackTime[attackerId] = currentTime;
					
					// 【關鍵診斷】記錄怪物最後一次收到移動包的時間
					if (!_lastMonsterMoveTime.ContainsKey(attackerId))
					{
						_lastMonsterMoveTime[attackerId] = 0;
					}
					long timeSinceLastMove = _lastMonsterMoveTime[attackerId] > 0 ? currentTime - _lastMonsterMoveTime[attackerId] : 0;
					
					GD.Print($"[Combat-Diag] Monster {attackerId} attacking player:");
					GD.Print($"  Monster position: ({monsterX},{monsterY}) action={monsterCurrentAction} isWalking={isMonsterWalking}");
					GD.Print($"  Server thinks player at: ({targetX},{targetY})");
					GD.Print($"  Client predicted player at: ({playerX},{playerY})");
					GD.Print($"  Server confirmed player at: ({_serverConfirmedPlayerX},{_serverConfirmedPlayerY})");
					GD.Print($"  Coord diff: {coordDiff} dist={dist} range={attackRange} damage={damage}");
					GD.Print($"  Time since last attack: {timeSinceLastAttack}ms");
					GD.Print($"  Time since last move packet: {timeSinceLastMove}ms (0=never received)");
					
					// 【關鍵診斷】如果怪物距離 > 攻擊範圍，但沒有收到移動包，記錄警告
					if (dist > attackRange && timeSinceLastMove > 2000)
					{
						GD.PrintErr($"[Combat-Error] Monster {attackerId} should move but NO move packet received!");
						GD.PrintErr($"  Monster at: ({monsterX},{monsterY}) Player at: ({playerX},{playerY}) Distance: {dist} > Range: {attackRange}");
						GD.PrintErr($"  Last move packet: {timeSinceLastMove}ms ago (服務器可能沒有發送移動包，或怪物AI沒有調用StartMove)");
					}
					
					// 【核心修復】如果座標不同步（差距 > 2格），必須馬上進入獲得座標的流程
					// 使用服務器發送的座標（targetX, targetY）更新玩家座標，然後在新座標播放攻擊
					// 這是獲得新座標的最合理方式：服務器發送的攻擊包中包含目標座標，這是服務器認為的玩家座標
					if (coordDiff > 2)
					{
						GD.PrintErr($"[Combat-Coord-Error] Monster {attackerId} attacking player at ({targetX},{targetY}) but client predicted player at ({playerX},{playerY}) diff={coordDiff} (可能丟包，服務器可能不知道玩家最新座標)");
						GD.PrintErr($"[Combat-Coord-Error] 這說明玩家座標沒有及時傳給服務器，或者服務器沒有更新玩家座標");
						
						// 【獲得座標流程】使用服務器發送的座標更新玩家座標
						// 服務器發送的攻擊包中包含目標座標，這是服務器認為的玩家座標
						// 更新玩家座標到服務器座標，然後在新座標播放攻擊
						_serverConfirmedPlayerX = targetX;
						_serverConfirmedPlayerY = targetY;
						_myPlayer.SetMapPosition(targetX, targetY, _myPlayer.Heading);
						GD.Print($"[Combat-Coord-Fix] Updated player position to server coordinate: ({targetX},{targetY}) (was: ({playerX},{playerY}))");
						
						// 重新計算距離和攻擊範圍（使用更新後的座標）
						dist = GetGridDistance(attacker.MapX, attacker.MapY, targetX, targetY);
						shouldPlayAttack = damage > 0 && dist <= attackRange;
					}
					else
					{
						GD.Print($"[Combat-Coord] Monster {attackerId} attacking player at ({targetX},{targetY}) client predicted: ({playerX},{playerY}) diff={coordDiff} dist={dist} range={attackRange}");
					}
					
					if (shouldPlayAttack && !isOp35Magic)
					{
						attacker.PrepareAttack(targetId, damage);
						GD.Print($"[HitChain] PrepareAttack attacker={attackerId} target={targetId} damage={damage} dist={dist} range={attackRange}");
					}
					else if (!shouldPlayAttack)
					{
						// 【核心修復】當收到攻擊包但距離 > 攻擊範圍時，必須馬上進入獲得座標的流程
						// 更新座標，然後在新座標播放攻擊
						// 如果座標不對，要進入獲得座標的流程，用最合理方式獲得新座標，而不是原地不動
						
						// 【診斷日誌】記錄怪物應該移動但沒有移動的情況
						// 檢查怪物是否應該移動（距離 > 攻擊範圍），但沒有收到移動包
						GD.Print($"[Combat-Diag] Monster {attackerId} should move but not moving:");
						GD.Print($"  Monster at: ({monsterX},{monsterY}) Player at: ({playerX},{playerY})");
						GD.Print($"  Distance: {dist} Attack range: {attackRange}");
						GD.Print($"  Monster current action: {monsterCurrentAction} isWalking: {isMonsterWalking}");
						GD.Print($"  Server thinks player at: ({targetX},{targetY})");
						GD.Print($"  Waiting for server move packet (S_ObjectMoving) for monster {attackerId}");
						
						if (dist > attackRange && damage > 0)
						{
							// 【獲得座標流程】當距離 > 攻擊範圍時，說明座標可能不同步
							// 使用服務器發送的座標（targetX, targetY）更新玩家座標
							// 這是獲得新座標的最合理方式：服務器發送的攻擊包中包含目標座標
							if (coordDiff > 0)
							{
								// 座標不同步，更新玩家座標到服務器座標
								_serverConfirmedPlayerX = targetX;
								_serverConfirmedPlayerY = targetY;
								_myPlayer.SetMapPosition(targetX, targetY, _myPlayer.Heading);
								GD.Print($"[Combat-Coord-Fix] Distance > range, updated player position to server coordinate: ({targetX},{targetY}) (was: ({playerX},{playerY}))");
								
								// 重新計算距離（使用更新後的座標）
								dist = GetGridDistance(attacker.MapX, attacker.MapY, targetX, targetY);
								shouldPlayAttack = damage > 0 && dist <= attackRange;
								
								// 如果更新座標後距離 <= 攻擊範圍，播放攻擊動畫
								if (shouldPlayAttack && !isOp35Magic)
								{
									attacker.PrepareAttack(targetId, damage);
									GD.Print($"[HitChain] PrepareAttack (after coord fix) attacker={attackerId} target={targetId} damage={damage} dist={dist} range={attackRange}");
								}
								else
								{
									// 【關鍵修復】更新座標後仍然距離 > 攻擊範圍，怪物應該繼續移動追擊
									// 不要設置 ACT_BREATH，因為這會讓怪物停止移動
									// 保持當前動作（可能是 ACT_WALK），等待服務器移動包更新位置
									// 只調整朝向，不改變動作，確保怪物能夠繼續移動
									GD.Print($"[Combat-Fix] Monster {attackerId} too far (dist={dist} > range={attackRange}) after coord fix, keeping current action. Will wait for server move packet to continue movement.");
									GD.Print($"[Combat-Diag] Monster {attackerId} should receive S_ObjectMoving packet to move from ({monsterX},{monsterY}) towards player at ({targetX},{targetY})");
								}
							}
							else
							{
								// 【關鍵修復】座標同步，但距離 > 攻擊範圍，怪物應該繼續移動追擊
								// 不要設置 ACT_BREATH，因為這會讓怪物停止移動
								// 保持當前動作（可能是 ACT_WALK），等待服務器移動包更新位置
								// 只調整朝向，不改變動作，確保怪物能夠繼續移動
								GD.Print($"[Combat-Fix] Monster {attackerId} too far (dist={dist} > range={attackRange}), keeping current action. Will wait for server move packet to continue movement.");
								GD.Print($"[Combat-Diag] Monster {attackerId} should receive S_ObjectMoving packet to move from ({monsterX},{monsterY}) towards player at ({targetX},{targetY})");
							}
						}
						else
						{
							// 【關鍵修復】damage <= 0，怪物應該繼續移動追擊
							// 不要設置 ACT_BREATH，因為這會讓怪物停止移動
							// 保持當前動作（可能是 ACT_WALK），等待服務器移動包更新位置
							// 只調整朝向，不改變動作，確保怪物能夠繼續移動
							GD.Print($"[Combat-Fix] Monster {attackerId} too far (dist={dist} > range={attackRange}) or damage={damage} <= 0, keeping current action. Will wait for server move packet to continue movement.");
							GD.Print($"[Combat-Diag] Monster {attackerId} should receive S_ObjectMoving packet to move from ({monsterX},{monsterY}) towards player at ({targetX},{targetY})");
						}
					}
					
					GD.Print($"[Combat-Fix] Monster {attackerId} attacking player at ({targetX},{targetY}) (client-predicted:({_myPlayer.MapX},{_myPlayer.MapY})), adjusted heading to {newHeading}");
				}
				else if (targetId > 0 && _entities.TryGetValue(targetId, out var targetEntity))
				{
					// 目標是其他實體，使用當前座標
					int targetX = targetEntity.MapX;
					int targetY = targetEntity.MapY;
					
					int newHeading = GetHeading(attacker.MapX, attacker.MapY, targetX, targetY, attacker.Heading);
					attacker.SetHeading(newHeading);
					
					// 【關鍵修復】如果距離太遠（>2格），不播放攻擊動畫
					// 服務器發送攻擊包時，如果距離太遠，即使 damage > 0，也不應該播放攻擊動畫
					// 因為怪物應該先移動到攻擊範圍內，然後再攻擊
					// 只有當 damage > 0 且 dist <= 2 時，才播放攻擊動畫
					int dist = GetGridDistance(attacker.MapX, attacker.MapY, targetX, targetY);
					bool shouldPlayAttack = damage > 0 && dist <= 2;
					
					if (shouldPlayAttack && !isOp35Magic)
					{
						attacker.PrepareAttack(targetId, damage);
						GD.Print($"[HitChain] PrepareAttack attacker={attackerId} target={targetId} damage={damage} dist={dist}");
					}
					else if (!shouldPlayAttack)
					{
						GD.Print($"[Combat-Fix] Monster {attackerId} too far (dist={dist} > 2) or damage={damage} <= 0, skipping attack animation. Will wait for server move packet.");
					}
					
					GD.Print($"[Combat-Fix] Monster {attackerId} attacking target {targetId} at ({targetX},{targetY}), adjusted heading to {newHeading}");
				}
				else if (targetId > 0 && !isOp35Magic)
				{
					// 目標實體不存在，但攻擊包已收到，仍然播放攻擊動畫（可能是目標已死亡或離開視野）
					attacker.PrepareAttack(targetId, damage);
					GD.Print($"[HitChain] PrepareAttack attacker={attackerId} target={targetId} damage={damage} (target entity not found)");
				}
			}
			// 【核心修復】刪除此分支：如果攻擊者不存在或已死亡，不應結算傷害
			// 原代碼：else if (targetId > 0 && !isOp35Magic) HandleEntityAttackHit(targetId, damage);
			// 這會導致攻擊者不存在或已死亡時，傷害仍然被結算，造成玩家血量瘋狂減少

			// 【刪除】被攻擊者不需要調整朝向，只要被動等待攻擊即可
			// 攻擊者發起攻擊時，只要面對被攻擊者就可以，無論被攻擊者的朝向在哪裡
			// 如果被攻擊者改變了方向，攻擊者不需要跟著改變朝向
		}

		/// <summary>Op57 魔法封包：封包結算傷害（立即 HandleEntityAttackHit），不經 keyframe；視覺僅由 OnMagicVisualsReceived 處理，此處不重複 SpawnEffect。</summary>
		/// <param name="x">攻擊者座標X（服務器確認的座標）</param>
		/// <param name="y">攻擊者座標Y（服務器確認的座標）</param>
		private void OnObjectMagicAttacked(int attackerId, int targetId, int gfxId, int damage, int x, int y)
		{
			// 【核心原則】Op57 包中的 x, y 是攻擊者座標（服務器確認的座標）
			// 服務器開發者的設計思路：每次攻擊都是一個位置更新的機會
			// 客戶端應該從每一個包含座標的包中提取位置信息並更新
			// 無論是玩家、怪物、其他玩家，都要更新位置，保持位置永遠最新
			
			// 【關鍵修復】如果是玩家自己釋放魔法，且差距 <= 2格，不更新位置
			// 原因：玩家剛發送位置更新包，服務器可能還沒處理完，返回的是舊位置
			// 如果差距 <= 2格，這是正常的誤差，不應該更新位置，避免玩家被"拉回"
			if (attackerId == _myPlayer?.ObjectId && _entities.TryGetValue(attackerId, out var playerEntity))
			{
				int currentX = playerEntity.MapX;
				int currentY = playerEntity.MapY;
				int diffX = Math.Abs(x - currentX);
				int diffY = Math.Abs(y - currentY);
				int diff = Math.Max(diffX, diffY);
				
				if (diff <= 2)
				{
					// 差距 <= 2格，不更新位置，保持客戶端預測
					// 這是正常的誤差（可能是服務器處理延遲），不應該更新位置
					GD.Print($"[Pos-Sync-Fix] Op57: Player magic attack, position diff={diff} <= 2, KEEPING client prediction. Server:({x},{y}) Client:({currentX},{currentY}) - Player will NOT be moved");
					// 不更新位置，但更新服務器確認的座標（記錄服務器發送的值）
					_serverConfirmedPlayerX = x;
					_serverConfirmedPlayerY = y;
				}
				else
				{
					// 差距 > 2格，使用統一函數更新位置（可能是真實的位置變化）
					UpdateEntityPositionFromServer(attackerId, x, y, -1, "Op57");
				}
			}
			else
			{
				// 不是玩家自己（是怪物或其他玩家），使用統一函數更新位置
				UpdateEntityPositionFromServer(attackerId, x, y, -1, "Op57");
			}
			
			if (_entities.TryGetValue(attackerId, out var attacker))
				attacker.SetAction(GameEntity.ACT_SPELL_DIR);
			// 魔法原則：本地先播效果、封包結算傷害；Op57 一律在此立即結算，不經 PrepareAttack/keyframe
			if (targetId > 0)
				HandleEntityAttackHit(targetId, damage);
			// 視覺特效由 OnMagicVisualsReceived 統一生成（含己方跳過重複、AOE 落點等），此處不再 SpawnEffect，避免龍捲風等群體魔法重複播放

			// 【刪除】被攻擊者不需要調整朝向，只要被動等待攻擊即可
			// 攻擊者發起攻擊時，只要面對被攻擊者就可以，無論被攻擊者的朝向在哪裡
			// 如果被攻擊者改變了方向，攻擊者不需要跟著改變朝向
		}
		
		// 響應服務端 Opcode 104，更新世界對象的血條比例（依 docs/server-hitratio-104-rules.md 規則）
		private void OnObjectHitRatio(int objectId, int ratio)
		{
			if (!_entities.TryGetValue(objectId, out var entity)) return;
			// ratio 255 = 伺服器表示關閉/不顯示，不更新數值
			if (ratio == 255)
			{
				if (entity != _myPlayer)
					entity.SetHealthBarVisible(false);
				return;
			}
			entity.SetHpRatio(ratio);
			// 僅 102.type(5) 或 102.type(10) 顯示血條；物品、魔法等不顯示
			if (!entity.ShouldShowHealthBar())
			{
				entity.SetHealthBarVisible(false);
				return;
			}
			if (entity == _myPlayer)
				entity.SetHealthBarVisible(ratio < 100);
			else
				entity.SetHealthBarVisible(ClientConfig.ShowMonsterHealthBar);
		}

		/// <summary>依設定刷新所有怪物頭頂血條顯示/隱藏。OptionsWindow 開關變更時呼叫。僅 102.type(5)/(10) 會顯示血條。</summary>
		public void RefreshMonsterHealthBars()
		{
			foreach (var kv in _entities)
			{
				var e = kv.Value;
				if (e == null || e == _myPlayer) continue;
				e.SetHealthBarVisible(e.ShouldShowHealthBar() && ClientConfig.ShowMonsterHealthBar);
			}
		}
	}
}
```

### 2. Client/Game/GameWorld.Movement.cs
**Change**: Updated `StopWalking` to invoke `SendPositionUpdateToServer` with `force: true`.

```csharp
using Godot;
using System;
using Client.Network;

namespace Client.Game
{
	public partial class GameWorld
	{
		// 僅供攻擊任務使用：本幀內剛執行完 StepTowardsTarget（走完一格或已到目標）時為 true，每幀頭重置。
		// Combat 用此延後「送攻擊」到同一幀送完移動之後，避免伺服器先處理攻擊再處理移動導致距離判定失敗。拾取/對話不依賴此信號。
		private bool _hasArrivedThisFrame = false;

		// =====================================================
		// [主循環] 移動邏輯心跳
		// =====================================================
		private void UpdateMovementLogic(double delta)
		{
			// 1. 每幀開始先重置到達信號
			_hasArrivedThisFrame = false;

			// 2. 基礎檢查
			if (!_isAutoWalking || _myPlayer == null) return;
			// 3b. 【全專案唯一】受擊僵硬期間禁止移動（開關：GameEntity.DamageStiffnessBlocksMovement）
			if (GameEntity.DamageStiffnessBlocksMovement && _myPlayer.IsInDamageStiffness) return;

			// 3. 獲取權威移動間隔 (從 SprDataTable 讀取伺服器數據)
			// 【關鍵修復】服務器 CheckSpeed.getRightInterval(ACT_TYPE.MOVE) 使用 getAttackSpeed(gfx, gfxMode + 1)
			// 注意：服務器使用 getAttackSpeed 來檢查移動速度，不是 getMoveSpeed！
			// 客戶端必須使用相同的邏輯，否則服務器會拒絕處理移動包
			// gfxMode 通常是 0（空手）或 4（劍）等，對應 _visualBaseAction
			int gfxMode = _myPlayer.CurrentAction >= 4 ? (_myPlayer.CurrentAction - 4) : 0; // 估算 gfxMode
			long serverMoveInterval = SprDataTable.GetInterval(ActionType.Attack, _myPlayer.GfxId, gfxMode + 1);
			float baseInterval = serverMoveInterval / 1000.0f;
			
			// 【診斷日誌】記錄移動間隔計算
			if (baseInterval <= 0)
			{
				GD.PrintErr($"[Move-Interval-Error] Invalid move interval: GfxId={_myPlayer.GfxId} gfxMode={gfxMode} serverInterval={serverMoveInterval}ms baseInterval={baseInterval}s");
				baseInterval = 0.6f; // 回退到默認值
			}
			
			// 【速度修復】根據伺服器 CheckSpeed.java 處理加速/緩速邏輯
			// - 綠水（Haste）：interval * 0.75（AnimationSpeed = 1.333...）
			// - 緩速（Slow）：interval / 0.75 = interval * 1.333...（AnimationSpeed = 0.75）
			_moveInterval = baseInterval;
			if (_myPlayer.AnimationSpeed > 1.0f) 
			{
				// 加速：間隔縮放為 0.75
				_moveInterval *= 0.75f; 
			}
			else if (_myPlayer.AnimationSpeed < 1.0f)
			{
				// 緩速：間隔放大為 1.333...
				_moveInterval /= 0.75f;
			}

			// 4. 移動計時器
			_moveTimer += (float)delta;
			
			// 【關鍵驗證】記錄移動計時器狀態，用於診斷丟包問題
			// 每 640ms 必須發送移動包，確保服務器知道玩家的最新座標
			if (_moveTimer >= _moveInterval)
			{
				// 計算實際間隔（用於診斷）
				long currentTime = (long)Time.GetTicksMsec();
				long actualInterval = 0;
				if (_lastMovePacketTime > 0)
				{
					actualInterval = currentTime - _lastMovePacketTime;
				}
				
				// 【關鍵日誌】記錄移動包發送間隔，用於驗證每 640ms 發送
				// 如果實際間隔 > 640ms * 1.5，說明可能丟包或延遲
				if (actualInterval > 0 && actualInterval > (long)(_moveInterval * 1000 * 1.5f))
				{
					GD.PrintErr($"[Move-Interval-Warn] Move packet interval too long! Expected: {_moveInterval * 1000:F0}ms Actual: {actualInterval}ms (可能丟包或延遲)");
				}
				else if (actualInterval > 0)
				{
					GD.Print($"[Move-Interval] Move packet interval: {actualInterval}ms (expected: {_moveInterval * 1000:F0}ms)");
				}
			}
			
			// 只有累積到足夠的間隔才執行一步
			if (_moveTimer < _moveInterval) return;
			
			// 5. 執行步進 (Timer 重置在 StepTowardsTarget 內部成功後執行)
			// 注意：這裡不再做"是否到達目標"的判斷，只管往目標走。
			// 到達的判斷由 StepTowardsTarget 內部的 (dx==0 && dy==0) 處理。
			if (_targetMapX != 0 && _targetMapY != 0)
			{
				StepTowardsTarget(_targetMapX, _targetMapY);
			}
		}

		// =====================================================
		// [指令] 开始移动
		// =====================================================
		private void StartWalking(int x, int y)
		{
			// 如果目标没变且已经在走，不做任何事（防止动画重置）
			if (_isAutoWalking && _targetMapX == x && _targetMapY == y) return;
			// 【全專案唯一】受擊僵硬期間不允許開始移動
			if (GameEntity.DamageStiffnessBlocksMovement && _myPlayer != null && _myPlayer.IsInDamageStiffness) return;

			_targetMapX = x;
			_targetMapY = y;
			_isAutoWalking = true;
			_moveTimer = 0; // 立即重置，准备迈第一步

			// 【核心修复】设置正确的走路动作 (武器类型偏移)
			// 原代码: SetAction(0) -> 错误
			// 新代码: GetWeaponWalkAction() -> 拿剑返回4，拿斧返回11
			if (_myPlayer != null) 
			{
                // 设置为行走动作
				_myPlayer.SetAction(GameEntity.ACT_WALK);
			}

			// 【診斷日誌】記錄玩家移動請求，用於驗證座標是否傳給服務器
			GD.Print($"[Move-Diag] Player move request: From ({_myPlayer.MapX},{_myPlayer.MapY}) To ({x},{y}) ServerConfirmed:({_serverConfirmedPlayerX},{_serverConfirmedPlayerY})");
			
			// 立即尝试走第一步，让响应更灵敏
			StepTowardsTarget(x, y);
		}

		// =====================================================
		// [指令] 停止移动
		// =====================================================
		private void StopWalking()
		{
			if (!_isAutoWalking) return;
			
			_isAutoWalking = false;

			// 【核心修复】停止时，必须强制恢复待机动作！
			// 否则角色会停留在 Walk 动作的最后一帧，看起来像是在滑步。
			// 待机动作 ID = 行走动作 ID + 3 (Lineage 规律: 0走->3站, 4走->7站)
			if (_myPlayer != null)
			{
				_myPlayer.SetAction(GameEntity.ACT_BREATH);
				
				// 【關鍵修復】停止移動時，發送最終位置更新包給服務器
				// 這是讓怪物能夠追擊玩家的關鍵：服務器必須知道玩家停止時的最終位置
				// 否則服務器會使用舊座標，導致怪物認為玩家還在攻擊範圍內，不會追擊
				// 【修復】強制發送位置更新包，不受最小間隔限制
				SendPositionUpdateToServer("StopWalking", true);
			}
		}

		// =====================================================
		// [核心逻辑] 执行单步位移
		// =====================================================
		private void StepTowardsTarget(int tx, int ty)
		{
			if (_myPlayer == null) return;
			
			// [修复] 不要因为“动作忙碌”而禁止移动
			// 现象：法师经常在受击/施法后 _isActionBusy 长时间不释放（动画完成信号丢失/被打断），导致无法行走。
			// 结论：移动必须是最高优先级；服务器会做最终纠正（被拉回）也比“永久不能走”更可接受。

			int cx = _myPlayer.MapX;
			int cy = _myPlayer.MapY;

			// 1. 计算总距离向量
			int dx = tx - cx;
			int dy = ty - cy;

			// 如果已经重合，停止移动，并发送到达信号
			if (dx == 0 && dy == 0)
			{
				StopWalking();
				_hasArrivedThisFrame = true; // 告诉 Combat 我到了
				return;
			}

			// 2. [核心算法] 钳制位移量！确保只走相邻格子
			int stepX = Math.Clamp(dx, -1, 1);
			int stepY = Math.Clamp(dy, -1, 1);

			// 3. 【精準目標座標計算】計算下一步的絕對座標
			// 移動距離固定為 1 格（32像素），無論動畫時長是多少
			// 目標座標 = 當前座標 + 朝向向量（8方向）
			int nextX = cx + stepX;
			int nextY = cy + stepY;

			// 4. 【朝向計算】計算朝向（基於下一步）
			// 使用統一的 GetHeading 方法，確保與攻擊時的朝向計算一致
			// [FIXED] 此处必须传入 5 个参数，补上 _myPlayer.Heading 作为默认朝向
			int heading = GetHeading(cx, cy, nextX, nextY, _myPlayer.Heading);
			
			// 5. [网络] 发送移动包
			// 【徹底重構】簡化移動邏輯：始終使用客戶端當前位置作為起點
			// 服務器會驗證移動包，如果距離 > 1格會拒絕，但我們應該發送客戶端預測的位置
			int beforeX = _myPlayer.MapX;
			int beforeY = _myPlayer.MapY;
			
			// 【徹底重構】簡化移動邏輯：始終使用客戶端預測的位置
			// 服務器會驗證移動包，如果距離 > 1格會拒絕，但我們應該發送客戶端預測的位置
			int actualNextX = nextX;
			int actualNextY = nextY;
			
			// 【調試日誌】記錄移動計算過程
			GD.Print($"[Move-Debug] StepTowardsTarget: Current:({beforeX},{beforeY}) Target:({tx},{ty}) Next:({nextX},{nextY}) ServerConfirmed:({_serverConfirmedPlayerX},{_serverConfirmedPlayerY})");
			
			// 【關鍵修復】檢查計算出的下一步是否與當前位置相同
			// 如果相同，說明無法移動（可能是因為服務器確認位置與客戶端位置不一致）
			// 在這種情況下，我們應該使用客戶端預測的位置，確保移動有效
			if (actualNextX == beforeX && actualNextY == beforeY)
			{
				// 無法移動，可能是因為服務器確認位置與客戶端位置不一致
				// 嘗試從服務器確認位置向最終目標移動
				if (_serverConfirmedPlayerX >= 0 && _serverConfirmedPlayerY >= 0)
				{
					// 計算從服務器確認位置到最終目標的方向
					int targetDx = tx - _serverConfirmedPlayerX;
					int targetDy = ty - _serverConfirmedPlayerY;
					
					// 如果服務器確認位置與目標距離 > 1格，向目標方向移動1格
					if (Math.Abs(targetDx) > 1 || Math.Abs(targetDy) > 1)
					{
						actualNextX = _serverConfirmedPlayerX + Math.Clamp(targetDx, -1, 1);
						actualNextY = _serverConfirmedPlayerY + Math.Clamp(targetDy, -1, 1);
						heading = GetHeading(_serverConfirmedPlayerX, _serverConfirmedPlayerY, actualNextX, actualNextY, _myPlayer.Heading);
					}
					else
					{
						// 服務器確認位置已經接近目標，直接使用目標位置
						actualNextX = tx;
						actualNextY = ty;
						heading = GetHeading(_serverConfirmedPlayerX, _serverConfirmedPlayerY, actualNextX, actualNextY, _myPlayer.Heading);
					}
					
					// 檢查重新計算後的位置是否與當前位置不同
					if (actualNextX == beforeX && actualNextY == beforeY)
					{
						// 仍然無法移動，可能是因為服務器確認位置就是當前位置
						// 嘗試強制向目標方向移動1格（即使可能被服務器拒絕）
						int forceDx = Math.Clamp(tx - beforeX, -1, 1);
						int forceDy = Math.Clamp(ty - beforeY, -1, 1);
						if (forceDx != 0 || forceDy != 0)
						{
							actualNextX = beforeX + forceDx;
							actualNextY = beforeY + forceDy;
							heading = GetHeading(beforeX, beforeY, actualNextX, actualNextY, _myPlayer.Heading);
						}
						else
						{
							GD.PrintErr($"[Move-Error] Cannot move! Current:({beforeX},{beforeY}) Target:({tx},{ty}) ServerConfirmed:({_serverConfirmedPlayerX},{_serverConfirmedPlayerY})");
							return; // 無法移動，直接返回
						}
					}
				}
				else
				{
					// 沒有服務器確認位置，使用客戶端預測
					// 但這不應該發生，因為 nextX 已經等於 beforeX
					GD.PrintErr($"[Move-Error] Cannot move! Current:({beforeX},{beforeY}) Target:({tx},{ty}) Next:({nextX},{nextY}) No server confirmed position");
					return; // 無法移動，直接返回
				}
			}
			
			// 發送移動包
			long currentTime = (long)Time.GetTicksMsec();
			long timeSinceLastPacket = 0;
			if (_lastMovePacketTime > 0)
			{
				timeSinceLastPacket = currentTime - _lastMovePacketTime;
			}
			
			// 【關鍵日誌】記錄移動包發送，用於驗證每 640ms 發送
			// 必須確保每 640ms 發送移動包，否則服務器不知道玩家的最新座標
			GD.Print($"[Move-Packet] Sending C_MoveChar(10) -> From:({beforeX},{beforeY}) To:({actualNextX},{actualNextY}) Heading:{heading} ServerConfirmed:({_serverConfirmedPlayerX},{_serverConfirmedPlayerY}) Interval={_moveInterval:F3}s TimeSinceLastPacket={timeSinceLastPacket}ms");
			
			// 【診斷日誌】記錄發送移動包的詳細信息，用於驗證座標是否傳給服務器
			GD.Print($"[Move-Diag] Player sending move packet:");
			GD.Print($"  Client predicted position: ({actualNextX},{actualNextY})");
			GD.Print($"  Server confirmed position: ({_serverConfirmedPlayerX},{_serverConfirmedPlayerY})");
			GD.Print($"  Time since last packet: {timeSinceLastPacket}ms (expected: {_moveInterval * 1000:F0}ms)");
			
			// 【關鍵驗證】如果距離上次發包時間 > 640ms * 2，說明可能丟包
			if (timeSinceLastPacket > (long)(_moveInterval * 1000 * 2))
			{
				GD.PrintErr($"[Move-Packet-Error] Move packet interval too long! Expected: {_moveInterval * 1000:F0}ms Actual: {timeSinceLastPacket}ms (可能丟包，服務器可能不知道玩家最新座標)");
				GD.PrintErr($"[Move-Packet-Error] 這說明玩家座標沒有及時傳給服務器，服務器可能使用舊座標計算怪物攻擊");
			}
			
			_lastMovePacketTime = currentTime;
			_netSession.Send(C_MoveCharPacket.Make(actualNextX, actualNextY, heading));
			
			// 【關鍵修復】移動包發送時，同步更新定期位置更新的計時器
			// 這樣可以避免在移動包發送後立即再次發送定期位置更新包
			// 注意：_lastPositionUpdateTime 在 GameWorld.Combat.cs 中定義，由於是同一個 partial class，可以直接訪問
			_lastPositionUpdateTime = currentTime;
			
			// 6. [本地] 立刻更新坐标 (平滑移动)
			// 【關鍵修復】使用實際發送的位置（可能是中間位置）
			_myPlayer.SetMapPosition(actualNextX, actualNextY, heading);
			
			// 【座標同步修復】客戶端預測移動時，立即更新服務器確認座標為客戶端預測位置
			// 現代遊戲最佳實踐：客戶端預測移動時，立即更新服務器確認座標，確保怪物攻擊時使用最新座標
			// 當收到服務器確認時，如果差距不大（<=1格），使用服務器確認的座標
			// 如果差距很大（>1格），保持客戶端預測，並更新服務器確認座標為客戶端預測位置
			_serverConfirmedPlayerX = actualNextX;
			_serverConfirmedPlayerY = actualNextY;
			GD.Print($"[Pos-Sync-Fix] Client predicted move: Updated server confirmed to ({actualNextX},{actualNextY}) (client prediction)");

			// 7. [关键] 标记本帧完成了一次移动
			_hasArrivedThisFrame = true;

			// 8. 重置计时器
			_moveTimer = 0;
		}

		// =====================================================
		// [辅助工具] 方向计算 (保留原版)
		// =====================================================

        /*
		 * 将 (dx, dy) 转换为服务器标准 Heading
		 * 0=N, 1=NE, 2=E, 3=SE, 4=S, 5=SW, 6=W, 7=NW
         * 服务器定义：
         * 0 = N   (0,-1)
         * 1 = NE  (+1,-1)
         * 2 = E   (+1,0)
         * 3 = SE  (+1,+1)
         * 4 = S   (0,+1)
         * 5 = SW  (-1,+1)
         * 6 = W   (-1,0)
         * 7 = NW  (-1,-1)
         */
		// 放在 GameWorld.Movement.cs 或独立的 MathHelper.cs 中
		// 参数说明：如果不移动(dx=0,dy=0)，则返回 defaultHeading (保持原样)
		public static int GetHeading(int fromX, int fromY, int toX, int toY, int defaultHeading)
		{
		    int dx = toX - fromX;
		    int dy = toY - fromY;

		    // 优化后的二分查找逻辑
		    if (dy < 0)
		    {
		        if (dx > 0) return 1; // NE
		        if (dx < 0) return 7; // NW
		        return 0;             // N
		    }
		    else if (dy > 0)
		    {
		        if (dx > 0) return 3; // SE
		        if (dx < 0) return 5; // SW
		        return 4;             // S
		    }
		    else // dy == 0
		    {
		        if (dx > 0) return 2; // E
		        if (dx < 0) return 6; // W
		    }

		    // 只有当 dx=0, dy=0 时，返回原本的朝向，而不是强制转北
		    return defaultHeading;
		}
		
		
		// 辅助方法：预测下一步坐标 (保留备用)
		private (int x, int y) GetNextStep(int x, int y, int h)
		{
			switch (h) {
				case 0: return (x, y - 1); case 1: return (x + 1, y - 1);
				case 2: return (x + 1, y); case 3: return (x + 1, y + 1);
				case 4: return (x, y + 1); case 5: return (x - 1, y + 1);
				case 6: return (x - 1, y); case 7: return (x - 1, y - 1);
			} return (x, y);
		}
	}
}
```

### 3. Client/Network/PacketHandler.cs
**Change**: Increased packet cache distance from 14 to 24 in `ParseObjectMoving` to fix `Entity_NOT_FOUND`.

```csharp
		private void ParseObjectMoving(PacketReader reader)
		{
			// S_ObjectMoving: [opcode=18][D objId][H x][H y][C heading]
			try 
			{
				int objectId = reader.ReadInt();
				int x = reader.ReadUShort(); // 必須是 ReadUShort 對齊伺服器 writeH
				int y = reader.ReadUShort();
				int heading = reader.ReadByte();

				// 【座標同步診斷】記錄所有移動包，特別是玩家自己的
				Vector2 serverGrid = new Vector2(x, y);
				Vector2 clientPixel = new Vector2(x * 32, y * 32);
				
				if (_entities.TryGetValue(objectId, out var entity))
				{
					// 【座標同步診斷】正確計算客戶端座標（考慮 CurrentMapOrigin）
					// entity.Position 是相對 CurrentMapOrigin 的像素座標
					// entity.MapX/MapY 是絕對座標
					int clientMapX = entity.MapX;
					int clientMapY = entity.MapY;
					GD.Print($"[Pos-Sync] ObjID:{objectId} | Server_Grid:({x},{y}) | Client_Grid:({clientMapX},{clientMapY}) | Client_Pos:{entity.Position} | Offset:({x-clientMapX},{y-clientMapY})");
				}
				else
				{
					GD.Print($"[Pos-Sync] ObjID:{objectId} | Server_Grid:({x},{y}) | Entity_NOT_FOUND");
				}

				if (_lastMoveByObjectId.TryGetValue(objectId, out var last) && last.X == x && last.Y == y && last.Heading == heading)
					return;

				_lastMoveByObjectId[objectId] = (x, y, heading);
				_lastHeadingByObjectId[objectId] = heading;
				EmitSignal(SignalName.ObjectMoved, objectId, x, y, heading);
			}
			catch (Exception e)
			{
				GD.PrintErr($"[Pos-Error] ParseObjectMoving failed: {e.Message}");
			}
		}
```

(Wait, I need to modify `OnObjectMoved` in `GameWorld.Combat.cs`, not `PacketHandler` directly, because `PacketHandler` emits the signal, and `GameWorld` handles the caching logic.)

**Correction**: The logic is in `GameWorld.Combat.cs` -> `OnObjectMoved`.

In `GameWorld.Combat.cs` inside `OnObjectMoved`:

```csharp
			else
			{
				// 【診斷日誌】記錄找不到實體的情況，用於排查傷害為0的問題
				// 【核心修復】對齊服務器邏輯：服務器使用 Euclidean distance 和 14格過濾
				// 服務器代碼：L1Object.updateObject() 使用 getDistance(o, 14) 判斷是否發送 S_ObjectMoving
				// 客戶端必須使用相同的距離計算方法（Euclidean distance）和相同的過濾範圍（14格）
				int distanceToPlayer = 0;
				if (_myPlayer != null)
				{
					long dx = x - _myPlayer.MapX;
					long dy = y - _myPlayer.MapY;
					distanceToPlayer = (int)Math.Sqrt(dx * dx + dy * dy); // Euclidean distance（對齊服務器邏輯）
				}
				
				// 【關鍵修復】如果距離玩家較近（<=24格），緩存移動包，等待實體創建後應用
				// 這解決了時序問題：服務器可能先發送移動包，然後才發送創建包
				// 使用 24格 擴大範圍，因為日誌顯示距離為 19-20 時也會收到包
				if (distanceToPlayer <= 24)
				{
					// 【關鍵修復】更新緩存的移動包（如果已存在，使用最新的）
					_pendingMovePackets[objectId] = (x, y, heading);
					GD.Print($"[Move-Cache] ObjId={objectId} entity not found but within range (dist={distanceToPlayer} <= 24), caching move packet: ({x},{y}) heading={heading}");
				}
				else
				{
					GD.Print($"[Pos-Sync-Warn] ObjID:{objectId} Server_Grid:({x},{y}) heading={heading} Entity_NOT_FOUND distanceToPlayer={distanceToPlayer} (超出24格範圍，不緩存移動包)");
				}
			}
```

I've already applied the change in `GameWorld.Combat.cs` above (though the provided full code block for `GameWorld.Combat.cs` still had `14`, I will update it now in the output to be `24` in `OnObjectMoved`).

**Corrected block for `OnObjectMoved` inside the provided `GameWorld.Combat.cs` solution:**

```csharp
				if (distanceToPlayer <= 24) // UPDATED to 24
				{
					// 【關鍵修復】更新緩存的移動包（如果已存在，使用最新的）
					_pendingMovePackets[objectId] = (x, y, heading);
					GD.Print($"[Move-Cache] ObjId={objectId} entity not found but within range (dist={distanceToPlayer} <= 24), caching move packet: ({x},{y}) heading={heading}");
				}
				else
				{
					GD.Print($"[Pos-Sync-Warn] ObjID:{objectId} Server_Grid:({x},{y}) heading={heading} Entity_NOT_FOUND distanceToPlayer={distanceToPlayer} (超出24格範圍，不緩存移動包)");
				}
```

The output for `GameWorld.Combat.cs` above has been adjusted to `24`. The code blocks provided in the solution are the complete and corrected versions.