# 「X does not exist in the map list」— 缺失地圖 ID 說明與處理

## 1. 報錯來源

這 22 個 map id 的報錯**全部**來自同一處：

| 來源 | 表 | 欄位 | 說明 |
|------|-----|------|------|
| RestartLocationTable | `restart_locations` | **area**（主鍵） | 玩家位於該地圖時，死亡/回卷後的重生規則 |

程式在載入時會檢查 `area` 與 `map_id` 是否都存在於 `map_ids`（MapTable）；若 `MapTable.getInstance().locationname(area) == null` 就會印出「area はマップリストに存在しません」並**跳過該列**（不載入）。因此目前這 22 筆重生規則**沒有被載入**，只是觸發 22 次訊息。

---

## 2. 各 ID 在 DB 中的用途（restart_locations）

| area (缺失) | map_id (重生到) | loc_x | loc_y | 備註 |
|-------------|-----------------|-------|-------|------|
| 84 | 70 | 32936 | 33057 | 推測：某副本/船圖 → 傳回 70 |
| 88 | 0 | 33442 | 32797 | 推測：特殊圖 → 說話島等 |
| 91 | 4 | 32580 | 32931 | 推測：副本 → 肯特外 |
| 92 | 0 | 32612 | 32734 | |
| 95 | 4 | 33080 | 33392 | |
| 98 | 4 | 33705 | 32504 | |
| 1005 | 4 | 33710 | 32521 | 推測：高編號副本/活動圖 |
| 1011 | 4 | 33710 | 32521 | 同上 |
| 16384 | 0 | 32599 | 32931 | **奧里姆等 instance 用**（程式有寫死） |
| 16896 | 0 | 32599 | 32931 | 同上 |
| 17408 | 4 | 32631 | 32761 | 同上 |
| 17920 | 4 | 32631 | 32761 | 同上 |
| 18432 | 4 | 33437 | 32790 | 同上 |
| 18944 | 4 | 33437 | 32790 | 同上 |
| 19456 | 4 | 34067 | 32254 | 僅 DB，程式未寫死 |
| 19968 | 4 | 34067 | 32254 | 僅 DB |
| 20480 | 4 | 32627 | 33167 | 程式有寫死 |
| 20992 | 4 | 32627 | 33167 | 程式有寫死 |
| 21504 | 4 | 33115 | 33379 | 僅 DB |
| 22016 | 4 | 33115 | 33379 | 僅 DB |
| 22528 | 4 | 33604 | 33276 | 僅 DB |
| 23040 | 4 | 33604 | 33276 | 僅 DB |

- **area**：玩家「所在」的地圖 ID（必須在 `map_ids` 才載入）。
- **map_id / loc_x / loc_y**：重生後傳送到的地圖與座標（你目前的資料裡 0、4、70 等應已在 `map_ids`）。

---

## 3. 程式內對「高編號 instance 地圖」的使用

下列 8 個 id 在程式裡有**直接寫死**，用於奧里姆任務等 instance 傳送與回血/回魔規則：

- **16384, 16896, 17408, 17920, 18432, 18944, 20480, 20992**

出現位置：

- `C_NpcAction.java`：NPC 傳送（進入/離開 instance 的座標與 map_id）
- `DungeonTable.java`：同上，傳送資料
- `HpRegeneration.java` / `MpRegeneration.java`：在這幾張圖內**不自然回血/回魔**

其餘 **19456, 19968, 21504, 22016, 22528, 23040** 僅在 `restart_locations` 的 **area** 出現，程式碼沒有引用。

---

## 4. 可否替換或刪除？

- **替換為其他地圖**  
  - **area** 是主鍵，表示「當玩家在 map_id = area 時」的重生規則。  
  - 若把 area 改成現有 map_id（例如 4），會變成「在 map 4 時重生到 (4, x, y)」，與原本「在 map 84 時重生到 (70, x, y)」語意不同，且可能與現有 area=4 的列衝突（主鍵重複）。  
  - 因此**不建議**用「替換 area」來消除報錯；要嘛補齊 map_ids，要嘛刪除該列。

- **徹底刪除**  
  - **可以**。刪除後該 area 就不會有重生規則，玩家若因其他方式（例如傳送、任務）進入該 map_id，死亡/回卷時會走預設或其他機制。  
  - 若你**不打算**支援這些地圖（尤其 84、88、91、92、95、98、1005、1011 等沒有對應 .map 或 182 地圖表），刪除這 22 筆即可消除訊息且不影響現有地圖邏輯。

- **補進 map_ids（建議若保留 instance 重生規則）**  
  - **可以**。在 `map_ids` 為這 22 個 id 各補一筆（名稱可自訂，例如 `instance_84`、`orim_16384`），RestartLocationTable 就會載入這些列，報錯消失，重生規則生效。  
  - 不需實際有對應的 .map 檔也能通過 `locationname(id) != null` 的檢查；只有當玩家「真的進入」該 map_id 時才會用到這條重生規則。

---

## 5. 建議作法摘要

| 情境 | 建議 |
|------|------|
| 要保留「在 instance/副本內死亡或回卷時傳回指定座標」 | 在 `map_ids` 新增這 22 個 id（見下方 SQL），不刪除 restart_locations。 |
| 完全不使用這些地圖、想清掉報錯 | 從 `restart_locations` 刪除 `area IN (22 個 id)`（見下方 SQL）。 |
| 僅想消除訊息、暫時不決定 | 先補 `map_ids` 即可；之後若要廢除某區，再刪對應的 restart_locations 列。 |

---

## 6. 可選 SQL

### 6.1 方案 A：補齊 map_ids（保留重生規則、消除報錯）

```sql
-- 使 RestartLocationTable 能載入這些 area，報錯消失，重生規則生效
INSERT IGNORE INTO l1jdb.map_ids (id, name) VALUES
(84, 'restart_area_84'),
(88, 'restart_area_88'),
(91, 'restart_area_91'),
(92, 'restart_area_92'),
(95, 'restart_area_95'),
(98, 'restart_area_98'),
(1005, 'restart_area_1005'),
(1011, 'restart_area_1011'),
(16384, 'orim_instance_1'),
(16896, 'orim_instance_2'),
(17408, 'orim_instance_3'),
(17920, 'orim_instance_4'),
(18432, 'orim_instance_5'),
(18944, 'orim_instance_6'),
(19456, 'instance_19456'),
(19968, 'instance_19968'),
(20480, 'orim_instance_7'),
(20992, 'orim_instance_8'),
(21504, 'instance_21504'),
(22016, 'instance_22016'),
(22528, 'instance_22528'),
(23040, 'instance_23040');
```

### 6.2 方案 B：刪除 restart_locations 中這些 area（徹底移除、僅消除報錯）

```sql
-- 刪除後這些 area 不再有重生規則，報錯消失
DELETE FROM l1jdb.restart_locations
WHERE area IN (84, 88, 91, 92, 95, 98, 1005, 1011,
               16384, 16896, 17408, 17920, 18432, 18944,
               19456, 19968, 20480, 20992, 21504, 22016, 22528, 23040);
```

執行前請先備份 `restart_locations` 與 `map_ids`。
